% $Id$
\chapter{Memory Allocation}	\label{chap:memalloc}
% chapter 7: memalloc

많은 사람들이 C 언어에서 pointer가 가장 배우기 힘들다고 말합니다.
그러나 사실 이 말은 pointer보다 pointer가 가리키는 메모리를 관리하기가
힘들다는 뜻입니다. C 언어는 상대적으로 저수준의 언어이기 때문에,
프로그래머가 메모리를 직접 할당해야 합니다.
% TODO: 번역
% In keeping with C's low-level flavor, programmers are often reponsible
% for explicitly allocating memory, yet it is easy to overlook the allocation
% of pointed-to object.
제대로 할당되지 않은 메모리를 가리키는 포인터를 쓰는 것은 심각한 버그를
발생하는 가장 주된 원인이 됩니다.

\section{Basic Allocation Problems}
% from 7.1
여러분이 직접 \TT{malloc}을 부르지 않는다해도, 여러분이 쓰려고 하는 메모리가
제대로 초기화되었는지 검사해야 합니다.

\begin{faq}
\q % 7.1
	이 코드는 왜 동작하지 않을까요?
\begin{verbatim}
  char *answer;
  printf("Type something:\n");
  gets(answer);
  printf("You typed \"%s\"\n", answer);
\end{verbatim}

\A
	\TT{gets()}에 전달된 포인터 변수인 \TT{answer}는 문자열이
	저장될 어떤 공간을 가리키고 있어야 합니다.  위의 코드에서는
	\TT{answer}가 어디를 가리키는 지 알 수 없습니다. 즉, 초기화되지
	않는 변수이기 때문에 다음 코드와 같이 잘못된 코드입니다:

\begin{verbatim}
  int i;
  printf("i = %d\n", i);
\end{verbatim}

	따라서 주어진 코드의 첫 줄에서 우리는 \TT{answer}가 어디를
	가리키는지 알 수 없습니다. 즉, 바로 위의 코드에서 \TT{i}가
	무슨 값을 가지는지 알 수 없는 것과 같은 이유입니다.
	(초기화되지 않은 지역 변수\footnote{uninitialized local variable}는
	일반적으로
	쓰레기 값을 가지게 됩니다.  이는 널 포인터와는 다릅니다.  질문
	1.30, 5.1을 참고하기 바랍니다)

	위와 같이, 간단히 질문하고 답변받는 프로그램에서는 포인터 대신
	지역 배열을 쓰는 것이 훨씬 간단합니다:

\begin{verbatim}
  #include <stdio.h>
  #include <string.h>

  char answer[100], *p;
  printf("Type something:\n");
  fgets(answer, sizeof answer, stdin);
  if ((p = strchr(answer, '\n')) != NULL)
    *p = '\0';
  printf("You typed \"%s\"\n", answer);
\end{verbatim}

	\noindent 이 예제는 \TT{gets()} 대신 \TT{fgets()}를 썼습니다.
	따라서 배열의 끝이 덮어쓰여질 염려가 없습니다.  (질문 12.23을
	참고하기 바랍니다.  불행히도 이 예에서는 \TT{fgets()}가 \TT{gets()}와는
	달리 마지막 \verb+\n+을 지우지 못합니다.) \TT{answer}에
	\TT{malloc()}으로 메모리를 할당하는 방법도 생각할 수 있습니다.
\end{faq}

\begin{faq}
\q % 7.2 COMPLETE
	\TT{strcat()}이 동작하지 않습니다.  코드는 다음과 같으며:
\begin{verbatim}
  char *s1 = "Hello, ";
  char *s2 = "world!";
  char *s3 = strcat(s1, s2);
\end{verbatim}
	\noindent 이상한 결과가 발생합니다.

\A
	질문 7.1에서 언급한 것처럼, 주 원인은 연결한 문자열을 저장할만한
	공간이 없다는 것입니다.  C 언어는 동적으로 문자열을 처리해주지 
	않습니다.
	C 컴파일러는 소스에서 요구한 만큼만 메모리를 할당합니다 (문자열의
	경우엔 문자 배열과 문자열 상수를 포함합니다).  프로그래머는
	문자열 연결(concatenation)과 같은 실행 시간 연산(run-time operation)에
	필요한 적절한 공간을 배열이나 \TT{malloc()}을 불러서 직접 만들어
	주어야 합니다.

	\TT{strcat()}은 어떠한 공간도 할당해주지 않습니다;  두번째 문자열은
	단순히 첫번째 문자열에 붙어서 연결됩니다.  그러므로 첫번째 문자열을
	저장하는 곳이 충분한 공간을 가지고 있어야 하며, 쓸 수 있어야(writable)
	합니다. 따라서 다음과 같이 배열로 선언하면 쉽습니다:

\begin{verbatim}
  char s1[20] = "Hello, ";
\end{verbatim}

	물론, 실전에 쓰기 위해서는 위와 같이 20이라는 상수를 쓰는 것은
	좋지 않습니다. 우리는 적절한 공간을 보장할 수 있는 어떠한 메커니즘을
	써서 공간을 할당해야 합니다.

	\noindent \TT{strcat()}이 첫번째 문자열을 가리키는 (질문에서는
	\TT{s1}) 포인터를 리턴하므로, 변수 \TT{s3}는 불필요합니다;
	\TT{strcat()}을 부른 다음에 결과는 \TT{s1}이 가리키고 있습니다.

	질문에서 \TT{strcat()}을 부른 코드는 크게 두가지 문제를 가지고ㅍㅍ
	있습니다:
	먼저 \TT{s1}이 충분한 공간을 가지고 있지 않다는 것과, 이 문자열이
	쓸 수 없는(read-only) 문자열이라는 것입니다.  질문 1.32를 참고하기
	바랍니다.

\R
	\cite{ctp} \S\ 3.2 \page{32}.
\end{faq}

\begin{faq}
\q % 7.3 COMPLETE
	그러나 매뉴얼(man) 페이지는 \TT{strcat()}이 인자로 두 개의
	\verb+char *+를 받는다고 씌여 있습니다.  어떻게 이 것만 가지고
	필요한 메모리 공간을 만들어 주어야 한다는 것을 알 수 있죠?

\A
	일반적으로 포인터를 사용할 때에는 항상 메모리 공간을 잡아 주어야
	한다고 생각해야 합니다.  만약 라이브러리 함수의 설명에 메모리 할당에
	대한 언급이 없다면, 대부분은 호출하는 쪽에서 알아서 해 주어야 합니다.

	UNIX 스타일의 매뉴얼(man) 페이지의 첫 부분에 있는 `Synopsis' 섹션,
	또는 ANSI C 표준에 나온 이러한 부분은 잘못 이해하기 쉽습니다.
	이들 문서에 나온 코드는 호출하는 입장이 아닌 함수를 만드는 입장에
	더 가깝기 때문입니다.  특히 포인터를 인자로 받는 (구조체나 문자열)
	대부분의 함수들은 포인터가, 어떤 오브젝트를 (구조체나 배열 --- 질문
	6.3, 6.4 참고) 가리켜야 하는 경우가 많으며, 이 오브젝트는 부르는
	입장에서 할당해 주어야 하는 경우가 대부분입니다.  다른 예로는
	\TT{time()} 함수와 (질문 13.12 참고) \TT{stat()} 함수를 들 수 있습니다.
\end{faq}

\begin{faq*}
\q[b] % 7.3b
	다음과 같은 코드를 실행했는데:
\begin{verbatim}
  char *p;
  strcpy(p, "abc");
\end{verbatim}
	\noindent 동작을 합니다.  왜 그러죠? 제 예상대로라면 프로그램이
	망가져야(crash) 하는데요.

\A
	추측컨대 아주 재수가 좋은 모양입니다.  초기화되지 않은 포인터 \TT{p}에
	어떤 쓰레기 값이 들어갔고, 그 값이 여러분이 쓸 수 있는 메모리 공간을
	가리키고 있었고, 그 공간이 어떤 중요한 목적으로 쓰이고 있지 않았기
	때문입니다.
\end{faq*}

\begin{faq*}
\q[c] % 7.3c
	포인터 변수는 얼마나 큰 메모리를 할당할까요?
\A
	아주 잘못된 질문입니다.  포인터 변수를 다음과 같이 선언했다고 할 때:
\begin{verbatim}
  char *p;
\end{verbatim}
	\noindent 여러분은 (좀더 정확히 말해서, 컴파일러는) 포인터 자체만
	저장할 수 있는 공간을 할당한 것입니다; 즉, 이 경우
	\verb+sizeof(char *)+ 바이트만큼의 메모리가 할당된 것입니다.
	그러나 이 포인터는 아직 어떠한 메모리도 가리키고 있지 않습니다.
	질문 7.1과 7.2를 참고하기 바랍니다.
\end{faq*}

\begin{faq}
\q % 7.4 COMPLETE
	다음과 같이 파일에서 줄 단위로 읽는 코드를 만들었습니다:
\begin{verbatim}
  char linebuf[80];
  char *lines[100];
  int i;

  for (i = 0; i < 100; i++) {
    char *p = fgets(linebuf, 80, fp);
    if (p == NULL) break;
    lines[i] = p;
  }
\end{verbatim}
	그런데 이 코드는 항상 마지막 줄을 두 번 복사하게 됩니다. 왜 그럴까요?

\A
	여러분이 선언한 \TT{linebuf}는 단지 한 줄만을 저장할 수 있는
	버퍼입니다.  \TT{fgets}를 부를 때마다, 기존의 줄은 덮어써져 버립니다.
	\TT{fgets}는 내부적으로 메모리를 할당해 주지 않습니다.
	에러가 났거나 \TT{EOF}를 만나지 않는다면, \TT{fgets}가 리턴하는
	값은 여러분이 첫번째 인자로 전해 준 포인터와 같습니다.
	(이 경우 \TT{linebuf}를 가리키는 포인터)

	이런 식으로 코드를 작성하려 한다면, 여러분이 각각의 줄을 저장할
	공간을 일일히 할당해 주어야 합니다.
	질문 20.2의 코드를 참고하기 바랍니다.

\R
	\cite{kr1} \S\ 7.8 \page{155};
	\cite{kr2} \S\ 7.7 \Page{164--5};
	\cite{ansi} \S\ 4.9.7.2;
	\cite{iso} \S\ 7.9.7.2;
	\cite{hs} \S\ 15.7 \page{356}
\end{faq}


\begin{faq}
\Q{7.5a}
	문자열을 리턴하는 함수를 만들었는데, 리턴한 문자열이
	쓰레기로 채워진 것 같습니다.  왜 그럴까요?
\A
	포인터가 적절한 메모리 공간을 가리키고 있는지 잘 검사해보시기
	바랍니다.
	예를 들어 다음과 같이 했다면 잘못한 것입니다:

\begin{verbatim}
  char *itoa(int n)
  {
    char retbuf[20];           /* WRONG */
    sprintf(retbuf, "%d", n);
    return retbuf;             /* WRONG */
  }
\end{verbatim}
	한 가지 방법은 (완전한 것은 아닙니다.  특히 이 함수가 재귀적으로
	호출되거나 동시에 이 함수를 여러번 부르고, 그 값을 사용하려 할 때에는
	쓸 수 없습니다.) 리턴할 버퍼를 다음과 같이 만드는 것입니다:
\begin{verbatim}
  static char retbuf[20];
\end{verbatim}
	질문 7.5b, 12.21, 20.1을 참고하기 바랍니다.
\R
	\cite{iso} \S\ 6.1.2.4.
\end{faq}

\begin{faq}
\Q{7.5b}
	그럼 문자열이나 기타 이런 것들을 리턴하려면 어떻게 해야
	하죠?
\A
	포인터를 리턴할 때에는 이 포인터가 정적으로 할당된
	(statically-allcated) 공간을 가리키고 있어야 합니다.
	또는 이 버퍼가 이 함수에 전달된 메모리를 가리키고 있거나, 이 버퍼가
	\TT{malloc()}으로 할당된 버퍼이어야 합니다.  절대로 지역(local,
	automatic) 배열을 가리키고 있어서는 안됩니다.
	
	질문 20.1을 참고하기 바랍니다.
\end{faq}

\begin{faq}
\Q{7.6}	\TT{malloc()}을 호출할 때 왜 ``warning: assignment of pointer
	from integer lacks a cast''라는 경고가 발생할까요?
\A	아마도 \TT{malloc}이 선언된 헤더 파일을 (\verb+<stdlib.h>+이나
	다른 헤더 파일) 포함시키지 않아서일 것입니다.  질문 1.25를
	참고하기 바랍니다.
\R
	\cite{hs} \S\ 4.7 \page{101}.
\end{faq}

\begin{faq}
\Q{7.7}
	어떤 코드를 보면 \TT{malloc()}이 리턴한 포인터를 대입할 포인터의
	타입으로 캐스팅한 것을 볼 수 있는 데, 왜 그럴까요?
\A
	ANSI/\cite{iso} C 표준에서 \verb+void *+를 소개되기 전에는 대개 포인터
	변환에 관계된 경고를 없애기 위해, 또는 불필요한 변환을 줄이기 위해
	이러한 캐스팅을 사용했습니다.

	ANSI/\cite{iso} C 표준에서는 이러한 캐스팅이 전혀 필요없습니다.
	그리고 현재 이런 캐스팅을 사용하는 것은 나쁜 프로그래밍 스타일로
	간주되기도 합니다.  왜냐하면 \TT{malloc()}이 선언되지 않았을 때
	발생할 수 있는 유용한 경고 메시지를 발생시키지 않기 때문입니다;
	질문 7.6을 참고하기 바랍니다.  (그러나 이런 캐스팅은 여전히
	자주 쓰이고 있습니다.  왜냐하면 C++에서는 이러한 캐스팅이 반드시
	필요하기 때문에, 호환성을 유지하기 위해서입니다.)

\R
	\cite{hs} \S\ 16.1 \Page{386--7}.
\end{faq}

\begin{faq}
\Q{7.8}
	다음과 같은 코드를 본 적이 있습니다:
\begin{verbatim}
  char *p = malloc(strlen(s) + 1);
  strcpy(p, s);
\end{verbatim}
	\noindent 제 생각에는 \verb+malloc((strlen(s) + 1) * sizeof(char))+로
	되어야 할 것 같은데요.
\A
	\verb+sizeof(char)+로 곱하는 것은 불필요합니다.  왜냐하면 정의에
	의해서 \verb+sizeof(char)+는 항상 1이기 때문입니다.
	다른 말로 하면 \verb+sizeof(char)+를 곱하는 것은 전혀 문제가
	되지 않습니다.  1을 곱하는 것은 아무런 영향을 끼치지 않기 때문입니다.
	추가적으로 \verb+size_t+ 타입을 쓰는 것이 도움이 될 때도 있습니다.
	질문 8.9를 참고하기 바랍니다.
\R
	\cite{iso} \S\ 6.3.3.4; 
	\cite{hs} \S\ 7.5.2 \page{195}.
\end{faq}

\begin{faq}
\Q{7.14}
	어떤 시스템에서는 \TT{malloc()}으로 메모리를 할당해도
	프로그램에서 이 메모리에 접근하기 전에는 운영체제가 메모리를
	할당하지 않는다고 들었습니다.  그래도 상관없을까요?
\A
	꽤 말하기 어려운 문제입니다.  표준에서는 이런 식으로 동작하는
	시스템이 있다고 말한 바가 없습니다.  물론 그러한 시스템이 없다고
	말한 바도 없습니다.
\R
	\cite{iso} \S\ 7.10.3.
\end{faq}

\begin{faq}
\Q{7.16}
	어떤 수학 계산을 하기 위해 꽤 큰 배열이 필요해서 다음과
	같이 코드를 작성했습니다:
\begin{verbatim}
  double *array = malloc(300 * 300 * sizeof(double));
\end{verbatim}
	\noindent 이 때 \TT{malloc()}은 널 포인터를 리턴하지 않았지만
	프로그램이 매우 이상하게 동작합니다.  제 생각에는 메모리를 겹쳐
	쓰는(overwrite) 현상이 발생한 것 같거나 \TT{malloc()}이 원하는 만큼의
	큰 메모리를 할당한 것 같지가 않습니다.
\A
	300 곱하기 300은 90000이라는 것을 생각하시기 바랍니다.  이 수치는
	다시 \TT{sizeof(double)}로 곱해야 하기 때문에 상당히 큰 크기입니다.
	이런 큰 배열이 꼭 필요하다면 꽤 주의를 기울여야 합니다.
	만약 여러분의 시스템에서 \verb+size_t+ 타입이 (\TT{malloc()}이 리턴하는
	타입) 32 비트라면, 그리고 \verb+int+가 16 비트라면, 그러한 공간을
	할당할 수 있을 지도 모릅니다 (질문 3.14 참고).
	그렇지 않다면 여러분은 이 메모리를 작은 크기로 쪼개어 쓰거나,
	또는 32 비트 컴퓨터나 컴파일러를 쓰거나, 비표준으로 제공되는
	메모리 할당 함수를 써야 할 것입니다.  질문 19.23도 참고하기 바랍니다.
\end{faq}

\begin{faq}
\Q{7.17}
	제 PC는 8 메가 바이트의 메모리를 보유하고 있습니다.
	그런데 왜 640K의 크기 밖에 쓸 수 없는 것일까요?
\A
	PC 호환의 세그먼트(segment) 구조를 사용하는 컴퓨터에서
	640K 이상의 메모리를 사용하는 것은 (특히 MS-DOS에서) 매우 어렵습니다.
	질문 19.23을 참고하기 바랍니다.
\end{faq}

\begin{faq}
\Q{7.19}
	제 프로그램은 \TT{malloc()} 내부에서 오류가 발생한 것
	같습니다.  그런데 제가 보기에는 제 프로그램에 잘못된 부분이 없는
	것 같습니다.  \TT{malloc()} 내부에 버그가 있는 게 아닐까요?
\A
	불행히도 프로그래머가 \TT{malloc()}이 내부적으로 유지하는
	데이터 구조를 망가뜨리기는 매우 쉽습니다.  또 그 결과 발생하는
	문제는 매우 다루기가 어렵습니다.  가장 흔히 발생하는 실수가
	\TT{malloc()}이 할당한 크기보다 더 많은 데이터를 쓰려고(write)
	하는 것입니다; 특히 문자열을 저장하기 위해 \verb2strlen(s) + 12을
	쓰지 않고 \TT{malloc(strlen(s))}를 쓰는 경우가 흔합니다.
	다른 문제로 이미 \TT{free()}를 호출한 메모리 블럭을 또 쓰려고
	하거나 \TT{free()}를 같은 포인터에 대해 두 번 호출하는 경우도
	있습니다.  또는 널 포인터를 \TT{realloc()}에 사용할 경우도
	있습니다 (질문 7.30을 참고).

	질문 7.26, 16.8, 18.2를 참고하기 바랍니다.
\end{faq}

\begin{faq}
\Q{7.20}
	동적으로 할당한 메모리를 해제한 다음에는 다시 쓸 수 있나요?
\A
	쓸 수 없습니다.  어떤 오래된 \TT{malloc()}에 대한 문서는
	해제된 메모리는
	변경되지 않는 상태로 남아 있다고 (left undisturbed) 씌여 있지만
	이는 잘못된 것이며, C 표준에도 언급되지 않은 사항입니다.

	대부분의 프로그래머들이 해제된 메모리의 내용을 일부러 다시 쓰지는
	않습니다만, 다음에 나온 singly-linked 리스트를 해제하는 코드를
	보시기 바랍니다:

\begin{verbatim}
  struct list *listp, *nextp;
  for (listp = base; listp != NULL; listp = nextp) {
    nextp = listp->next;
    free(listp);
  }
\end{verbatim}
	그리고 임시 포인터인 nextp를 쓰지 않고
	`\verb+listp = listp->next+'를
	쓰는 것이 더 좋다는 것을 아셔야 합니다.

\R
	\cite{kr2} \S\ 7.8.5 \page{167}; 
	\cite{iso} \S\ 7.10.3; 
	\cite{rationale} \S\ 4.10.3.2; 
	\cite{hs} \S\ 16.2 \page{387}; 
	\cite{ctp} \S\ 7.10 \page{95}.
\end{faq}

\begin{faq}
\Q{7.21}
	왜 \TT{free()}를 부른 다음에 포인터가 널이 되지 않는
	걸까요?
\A
	\TT{free()}를 부르면 이 함수에 전달된 포인터가 가리키고 있던
	메모리가 해제됩니다.  그러나 이 포인터 자체의 값은 변경되지 않고
	남아있습니다.  왜냐하면 C 언어는 인자를 전달할 때, `pass-by-value'
	개념을 쓰기 때문입니다.  따라서 함수가 (이 경우 \TT{free()}) 인자로
	전달된 변수의 값을 변경할 수 없습니다.  (질문 4.8을 참고하기
	바랍니다.)

	일단 해제된 포인터 값은 엄밀히 말해서, 유효하지 않습니다(invalid).
	그리고 (dereference가 아니더라도) 어떠한 목적으로도 이 값을 쓰는 것은,
	물론 구현 방법에 따라 다르긴 하지만, 이론상 문제를 발생할 수 있습니다.
	대부분 implementation상 별 문제를 발생시키지 않는 한 invalid 포인터에
	대한 exception을 발생시키지 않습니다.

\R
	\cite{iso} \S\ 7.10.3; 
	\cite{rationale} \S\ 3.2.2.3.
\end{faq}

\begin{faq}
\Q{7.22}
	함수에 속한 지역(local) 포인터에 \TT{malloc()}으로
	메모리를 할당했을 때에도 반드시 \TT{free()}를 해주어야 하나요?
\A
	당연합니다.  포인터와 포인터가 가리키는 메모리는 서로 다른 것이라는
	것을 기억해야 합니다.  함수가 끝났을 때, 지역 변수로 선언한 포인터는
	자동으로 해제되지만, 포인터 자체가 해제된다는 뜻이지, 포인터가
	가리키는 메모리 블럭이 해제된다는 것은 아닙니다.
	\TT{malloc()}으로 할당한 메모리는 \TT{free()}를 써서 해제하기 전에는
	메모리에 남아 있습니다.  일반적으로 모든 \TT{malloc()}에는 각각의
	호출에 해당하는 \TT{free()}를 만들어 주어야 합니다.
\end{faq}

\begin{faq}
\Q{7.23}
	동적으로 할당한 어떤 오브젝트를 가리키는 포인터를 포함하는
	구조체를 할당했습니다.  이 구조체를 해제할 때, 각각의 포인터 멤버가
	가리키는 메모리도 따로 해제해 주어야 하나요?
\A
	그렇습니다.  \TT{malloc()}으로 할당한 메모리는 각각 (정확히
	딱 한번) \TT{free()}를 해주어야 합니다.  프로그램에서 각각
	\TT{malloc()}으로 할당한 메모리는 모두 \TT{free()}시키는 것이
	좋은 습관입니다.

	질문 7.24를 참고하기 바랍니다.
\end{faq}

\begin{faq}
\Q{7.24}
	프로그램이 끝나기 전에 동적으로 할당한 메모리는
	반드시 해제시켜야 하나요?
\A
	그럴 필요는 없습니다.  일반적으로 운영체제는 프로그램이 끝났을 때,
	프로그램이 할당한 모든 메모리를 해제시켜 줍니다.  그럼에도
	불구하고, 어떤 PC에서는 메모리를 제대로 복원시키지 못한다고
	알려져 있습니다.  ANSI/\cite{iso} C 표준에서는 이런한 상황을
	`구현 수준에 따른 상황(quality of implementation issue)'이라고
	말하고 있습니다.
\R
	\cite{iso} \S\ 7.10.3.2.
\end{faq}

\begin{faq}
\Q{7.25}
	제 프로그램은 메모리 블럭을 \TT{malloc()}으로 할당하고,
	나중에 \TT{free()}시키는 구조를 가집니다.  그런데, 프로그램이 끝난
	다음에도, 운영 체제의 메모리 상태를 살펴보면 전혀 줄어들지 않는
	것을 볼 수 있습니다.
\A	대부분의 \TT{malloc/free}의 구현 방법들은 메모리를 운영체제에
	즉시 반환하는 것이 아니며, 단지 그 프로그램에서 나중에 나올 
	\TT{malloc()}이	그 메모리를 다시 쓸 수 있도록 해 주도록 되어
	있습니다.
\end{faq}

\begin{faq}
\Q{7.26}
	\TT{free()} 함수는 어느 정도 크기의 메모리를 해제할 지
	어떻게 알 수 있는 것일까요?
\A
	\TT{malloc/free} 구현은 동적으로 할당한 각각의 메모리 블럭의 크기를
	내부적으로 유지하고 있습니다.  따라서 \TT{free()}를 쓸 때에
	그 크기를 지정하지 않아도 자동으로 그 크기를 알 수 있습니다.
\end{faq}

\begin{faq}
\Q{7.27}
	그렇다면, 할당한 블럭의 크기가 어느 정도인지 \TT{malloc}
	패키지를 써서 알 수 있을까요?
\A
	불행하게도, 동적 블럭의 크기를 알 수 있는 표준 또는 호환성있는
	방법은 제공되지 않습니다.
\end{faq}

\begin{faq}
\Q{7.30}
	\TT{realloc} 함수의 첫번째 인자로 널 포인터를 전달하는
	것이 안전한가요? 그리고 왜 그런 일을 하는 것이죠?
\A
	ANSI C 표준은 그런 식으로 써도 (그리고 \verb+realloc(..., 0)+처럼
	써서 메모리를 해제하는 것) 괜찮다고 말합니다.  그러나 대부분의
	오래된 구현 방법에서는 이러한 사용법을 제공하지 않습니다.
	따라서 표준이기는 하지만 완전히 호환성을 갖춘 방법이 아닙니다.
	\TT{realloc}의 첫 인자로 널 포인터를 전달하면 메모리를
	증가적으로 동적으로 할당하는 알고리즘을 (self-starting incremental
	allocation algorithm) 만들기 쉽습니다.
\R
	\cite{iso} \S\ 7.10.3.4; 
	\cite{hs} \S\ 16.3 \page{388}.
\end{faq}

\begin{faq}
\Q{7.31}
	\TT{calloc()}과 \TT{malloc()}의 차이는 무엇인가요?
	\TT{calloc()}이 메모리를 0으로 만드는 것을 믿고 쓸 수 있나요?
	그리고, \TT{calloc()}으로 할당한 메모리를 \TT{free()}를 써서
	해제할 수 있나요? 아니면 \TT{cfree()}와 같은 것을 사용하나요?
\A
	\TT{calloc()}은 다음의 코드를 수행하는 것과 같습니다:
\begin{verbatim}
  p = malloc(m * n);
  memset(p, 0, m * n);
\end{verbatim}
	\noindent 0으로 채운다는 것은 할당한 메모리의 모든 비트를
	0으로 채운다는 뜻입니다.  따라서 이 값이 널 포인터가 아닐 수도
	있으며(여기에 관한 것은 5 절을 참고하기 바랍니다.)
	실수(floating-point)로 0이 아닐 수도 있습니다.
	그리고 \TT{calloc()}으로 할당한 메모리를 해제할 때에도 \TT{free()}를
	씁니다.
\R
	\cite{iso} \S\ 7.10.3부터 7.10.3.2; 
	\cite{hs} \S\ 16.1 \page{386}, \S\ 16.2 \page{386}; 
	\cite{pcs} \S\ 11 \Page{141--142}.
\end{faq}

\begin{faq}
\Q{7.32}
	\TT{alloca()} 함수는 어떤 함수이며, 왜 쓰지 말라고 하죠?
\A
	\TT{alloc()}은 이 함수를 호출한 함수가 끝날 때, 자동으로 할당한
	메모리를 해제해 주는 함수입니다.  즉, \TT{alloca}로 할당한 메모리는
	특정 함수의 ``스택 프레임(stack frame)''이나 문맥(context)에
	종속적입니다.

	\TT{alloca()} 함수는 이식성있게 만들 수가 없습니다.  그리고
	일반적인 스택을 사용하지 않는 컴퓨터에서는 매우 만들기 어려운
	함수입니다.  특히 \TT{alloca}로 할당한 메모리를 리턴하는 경우,
	심각한 문제가 발생할 수 있습니다.  예를 들면:
\begin{verbatim}
  fgets(alloca(100), 100, stdin);
\end{verbatim}

	이런 이유에서 \TT{alloca} 함수는 표준 함수가 아니며, 높은 이식성이
	요구되는 프로그램에서는 (매우 쓸모 있기는 하지만) 쓸 수 없습니다.

	질문 7.22를 참고하기 바랍니다.
\R
	\cite{rationale} \S\ 4.10.3.
\end{faq}
