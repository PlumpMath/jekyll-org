\chapter{Boolean Expressions and Variables}	\label{chap:boolexpr}
% chapter 9: boolexpr

\begin{faq}
\Q{9.1}
	C 언어에서 불리언(boolean) 값으로 쓸 수 있는 괜찮은 타입이 있을까요?
	그리고 왜 그런 타입이 표준으로 지정되어 있지 않는 거죠?
	참(true)과 거짓(false)을 나타내기 위해 \verb+#define+으로
	정의를 하는 게 좋을까요, 아니면 \TT{enum}을 쓰는 것이 좋을까요?

\A
	C 언어는 표준으로 제공하는 불리언 타입이 없습니다.
	왜냐하면, 불리언 타입은 항상 공간/처리시간의 `tradeoff' 문제를
	가지기 때문입니다.  따라서 이는 프로그래머가 알아서 결정하도록
	해 놓은 것입니다.  (\TT{int}를 쓰면 빠르기는 하지만
	\TT{char}를 쓰는 것보다
	공간이 낭비될 것입니다.  반면 작은 데이터 타입을 쓰면, 그 만큼
	코드의 크기가 커지거나, 느려질 수 있습니다.)

	\verb+#define+과 \TT{enum} 중 어느 것을 쓸 것인지는 그리 큰 문제가
	되지 않습니다 (질문 2.22와 17.10을 참고하기 바랍니다.)
	다음 둘 중 아무 것이나 써도 좋으며, 0과 1을 직접 써도 좋습니다:

\begin{verbatim}
  #define TRUE  1             #define YES 1
  #define FALSE 0             #define NO  0

  enum bool {false, true};    enum bool {no, yes};
\end{verbatim}
	\noindent 그러나 일단 어떤 것을 쓰겠다고 정했다면, 한 프로그램이나
	프로젝트 내에서는 계속 그것을 쓰는 것이 좋습니다.  (그러나 디버거에서
	변수의 값을 검사할때, 수치가 아닌 이름으로 보여 줄 수 있으므로
	\TT{enum}이 더 좋을 수도 있습니다.)

	어떤 사람들은 다음과 같이 쓰는 것을 선호합니다:
\begin{verbatim}
  #define TRUE (1==1)
  #define FALSE (!TRUE)
\end{verbatim}
	\noindent 또는 다음과 같이 ``도우미(helper)'' 매크로를 만듭니다:
\begin{verbatim}
  #define Istrue(e) ((e) != 0)
\end{verbatim}

	그렇지만 이런 방식이 특별히 좋다는 것은 아닙니다.  (질문 9.2를
	참고하기 바랍니다; 질문 5.12와 10.2도 보시기 바랍니다).
\end{faq}

\begin{faq}
\Q{9.2}	\verb+#define+을 써서 \TT{TRUE}를 1로 만드는 것은 위험하지 않을까요?
	C 언어에서는 0이 아닌 비트가 하나라도 있으면 참(true)으로 인식될
	테니까요.  만약에 어떤 함수나 연산자가 1이 아닌 다른 값을 리턴할 경우
	어떻게 되는 거죠?

\A
	맞습니다.  사실 C 언어에서는 0이 아닌 모든 값이 참(true)입니다.
	그러나 이것은 단지 ``입력''일 경우에만 의미를
	가집니다; 다시 말하면 어떤 불리언 값이 예상되는 경우에만 그 의미를
	가집니다.  만약 불리언 값이 내장된(built-in) 연산자에 의해 만들어진
	것이라면 분명히 0 또는 1의 값을 가지게 됩니다.  따라서 다음과 같이
	코드를 만들어도 안전합니다 (\TT{TRUE}가 1이라고 가정할 때):
\begin{verbatim}
  if ((a == b) == TRUE)
\end{verbatim}
	그러나 어떤 값이 \TT{TRUE}와 같은 지 검사하는 것은 여전히 위험합니다.
	왜냐하면 어떤 라이트러리 함수들은 (특히 \TT{isupper()},
	\TT{isalpha()}, 등등) 참(true)을 나타내기 위해 1이 아닌 다른 값도
	쓰기 때문입니다.  (게다가 \verb+if ((a == b) == TRUE)+를 쓰려 한다면
	\verb+if (a == b)+를 쓰는 것이 더 좋지 않을까요?)
	값을 대입할 때, 함수의 인자로 전달할 때, 또는 불리언 값을
	리턴할 때에만 \TT{TRUE}나 \TT{FALSE}를 쓰는 것이 좋습니다.
	즉, 비교할 때에 이런 것을 쓰는 것은 좋지 않습니다.

	전처리기(preprocessor) 매크로인 \TT{TRUE}, \TT{FALSE}는 (물론
	\TT{NULL} 포함) 단지 코드를 읽기 쉽게 하기 위해 쓰는 것이지,
	이들 매크로가 나타내는 값이 바뀔 가능성이 있기 때문은
	아닙니다.  (질문 5.3과 5.10을 참고하기 바랍니다.)

	\TT{TRUE}나 \TT{FALSE}와 같은 (또는 \TT{YES}와 \TT{NO}) 매크로를
	쓰는 것은 어떻게 보면 좋은 것 같지만 C 언어에서 불리언 값이라는
	개념이 헷갈리기 때문에, 어떤 프로그래머들은
	0과 1이라는 수치를 직접 쓰는 것을 선호하기도 합니다.  (질문 5.9를
	참고하기 바랍니다.)

\R
	\cite{kr1} \S\ 2.6 \page{39}, \S\ 2.7 \page{41}; 
	\cite{kr2} \S\ 2.6 \page{42}, \S\ 2.7 \page{44}, 
		\S\ A7.4.7 \page{204}, \S\ A7.9 \page{206}; 
	\cite{iso} \S\ 6.3.3.3, \S\ 6.3.8, \S\ 6.3.9, \S\ 6.3.13, 
		\S\ 6.3.14, \S\ 6.3.15, \S\ 6.6.4.1, \S\ 6.6.5; 
	\cite{hs} \S\ 7.5.4 \Page{196--7}, \S\ 7.6.4 \Page{207--8}, 
		\S\ 7.6.5 \Page{208--9}, \S\ 7.7 \Page{217--8},
		\S\ 7.8 \Page{218--9}, \S\ 8.5 \Page{238--9}, 
		\S\ 8.6 \Page{241--4};
		``What the Tortoise Said to Achilles''.
\end{faq}

\begin{faq}
\Q{9.3}
	\TT{p}가 포인터일때, \verb+if (p)+와 같은 코드를 쓰는 것은
	나쁜가요?
\A
	아닙니다.  좋습니다.  질문 5.3을 참고하기 바랍니다.
\end{faq}
