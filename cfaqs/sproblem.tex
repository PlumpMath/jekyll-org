\chapter{Strange Problems}	\label{chap:sproblem}
% chapter 16: sproblem
\begin{faq}
\Q{16.1b}
	문법 오류(syntax error)가 엄청나게 많이 발생했는데 도저히 그
	이유를 모르겠습니다.

\A
	먼저 헤더 파일과 소스 파일 전체에서
	\verb+#if+/\verb+#ifdef+/\verb+#ifndef+/\verb+#else+/\verb+#endif+의
	쌍이 맞지 않는지 검사해보기 바랍니다.
	(\seealso{2.18, 10.9, 11.29})
\end{faq}

\begin{faq}
\Q{16.1c}
	왜 제 프로시져를 호출하는 부분이 동작하지 않을까요? 아무리 봐도
	컴파일러가 프로시져 호출 부분을 건너 뛰어 버리는 것 같습니다.

\A
	혹시 다음과 같이 코드를 작성하지 않았나요?
\begin{verbatim}
  myprocedure;
\end{verbatim}
	\noindent
	C 언어는 함수(function)만을 지원합니다.  그리고 함수에 전달되는
	인자가 하나도 없더라도 괄호로 둘러싼 `argument list'를 써 주어야
	합니다.  따라서 다음과 같이 써야 합니다:

\begin{verbatim}
  myprocedure();
\end{verbatim}
\end{faq}

\begin{faq}
\Q{16.3}
	동작하기도 전에 프로그램이 깨져버립니다.  (디버거로 한 스텝씩
	따라하면 \TT{main()}에 들어가기도 전에 죽어 버립니다.)
\A
	아마도 하나 이상의 (1KB 이상의)  매우 큰 local 배열을 썼을
	것입니다.  대부분의 시스템은 고정된 크기의 스택을 가지고 있고,
	동적으로 스택을 할당하는 (e.g.  Unix) 시스템이더라도 스택이
	갑자기 매우 커지려고 하면 혼란을 겪게 됩니다.  매우 큰 배열이
	필요하다면 정적(static)으로 할당하는게 좋습니다 (함수를 호출할 때마다
	새로운 배열이 필요하다면 \TT{malloc()}을 써서 할당하는 게 좋습니다.
	\seealso{1.31}).

	(\seealso{11.12b, 16.4, 16.5, 18.4})
\end{faq}

\begin{faq}
\Q{16.4}
	제 프로그램은 정상적으로 동작하는데, 끝나기 직전에 박살납니다.
	즉 \TT{main()}의 마지막 문장을 실행한 다음에 깨지는 거죠.
	왜 그럴까요?
\A
	\TT{main()}이 잘못 선언되었는지 검사해보기 바랍니다
	(\seealso{2.18, 10.9}), 또는 \TT{setbuf()}나 \TT{setvbuf()}에
	local 버퍼가 전달되었는지도 검사해보기 바랍니다.  또는 \TT{atexit()}로
	등록한 함수에 문제가 있을 확률도 있습니다.  \seealso{7.5a, 11.16}

\R
	\cite{ctp} \S\ 5.3 \Page{72--3}.
\end{faq}

\begin{faq}
\Q{16.5}
	이 프로그램은 어떤 컴퓨터에서는 완벽하게 돌아가지만, 다른
	컴퓨터에서 돌리면 이상한 결과를 만들어 냅니다.  더욱 이상한 것은,
	
16.5:	This program runs perfectly on one machine, but I get weird
	results on another.   Stranger still, adding or removing a
	debugging printout changes the symptoms...

\A
	이런 증상을 만들어 내는 이유는 많습니다.  아래에 일반적으로
	문제를 일으키는 경우가 있으니, 참고하시기 바랍니다:

	\begin{itemize}
	\item 초기화되지 않은 변수 (\seealso{7.1})
	\item 정수 오버플로우, 특히 16-bit 컴퓨터에서
		\verb+a * b / c+와 같은 연산을 할 때 (\seealso{3.14})
	\item 평가 순서가 정의되지 않은 경우 (질문 3.1에서 3.4까지 참고)
	\item external 함수의 선언이 생략되었을 경우.  특히 \TT{int}가 아닌
		다른 타입을 리턴하거나 ``좁은'' 또는 가변 인자를 가진 경우
		(질문 1.25, 11.3, 14.2, 15.1 참고)
	\item 널 포인터를 dereference한 경우 (section 5 참고)

	\item \TT{malloc}/\TT{free}를 잘 못 쓴 경우, 특히 \TT{malloc}으로
		할당한 메모리가 0으로 초기화되었다고 가정한 경우나,
		이미 \TT{free}한 메모리를 계속 쓴 경우, 두 번 \TT{free}한
		경우, \TT{malloc}이 할당한 부분을 벗어나서 작업한 경우
		(\seealso{7.19, 7.20})

	\item 일반적인 포인터 문제거리들 (\seealso{16.8})

	\item \TT{printf()} 포맷과 인자가 서로 맞지 않은 경우, 특히
		\verb+%d+를 써서 \TT{long int}를 출력하려 한 경우
		(질문 12.9 참고)

	\item \TT{unsigned int}가 표현할 수 있는 범위 밖의 크기의 메모리를
		할당하려 한 경우, 특히 메모리에 제한 사항이 많은 컴퓨터에서.
		(\seealso{7.16, 19.23})

	\item 배열 경계 문제거리들.  특히 작은 임시 버퍼를 쓸 때나
		\TT{sprintf()}를 써서 문자열을 다룰 때.  (\seealso{7.1, 12.21})

	\item \TT{typedef}된 타입을 특정 타입으로 잘못 예상하고
		코딩한 경우, 특히 \verb+size_t+에 대해.

	\item 실수(floating point) 처리 문제 (\seealso{14.1, 14.4})

	\item 특정 시스템에서만 동작하게 되어 있는 교묘한 코드를
		사용한 경우
	\end{itemize}

	\noindent 올바른 함수 prototype을 사용한다면 이런 종류의 많은 문제를
	미리 잡아낼 수 있습니다; \TT{lint}를 쓰는 것도 좋은 방법입니다.
	\seealso{16.3, 16.4, 18.4}
\end{faq}

\begin{faq}
\Q{16.6}
	왜 이 코드가 동작하지 않을까요?:
\begin{verbatim}
  char *p = "hello, world!";
  p[0] = 'H';
\end{verbatim}

\A
 	문자열 상수(string literal)은 다음과 같이 배열의 초기값으로 쓰는
	경우를 제외하고는 반드시 변경할 수 있어야 하는 것이 아닙니다.  따라서
	다음과 같이 써 보기 바랍니다:
\begin{verbatim}
  char a[] = "hello, world!";
\end{verbatim}

	\seealso{1.32}

\R
	\cite{iso} \S\ 6.1.4; 
	\cite{hs} \S\ 2.7.4 \Page{31--2}.
\end{faq}

\begin{faq}
\Q{16.8}
	``Segmentation violation''이나 ``Bus error''가 의미하는 것은
	무엇일까요?
\A
	일반적으로 이런 메시지의 뜻은, 스택이 망가졌거나 포인터를 잘못써서,
	읽거나 쓸 수 없는 메모리에 접근하려 했다는 뜻입니다.
	또 local array 경계를 넘어섰을 때에도, 널 포인터를 잘못 썼을 경우에도
	(\seealso{5.2, 5.20}) 이런 결과를 예상할 수 있습니다.
	다른 이유로는 잘못할당한 포인터 (질문 7.1, 7.2 참고), \TT{malloc}으로
	할당한 영역의 파괴 (질문 7.19 참고), 잘못된 함수 인자 사용 (특히
	포인터 인자; \TT{scanf}와 \TT{fprintf}에서 일어날 수 있는 두가지
	가능성, \TT{scanf}의 경우 질문 12.12 참고, \TT{fprintf}에서는
	첫번째 인자 타입이 \verb+FILE *+인 것에 주의).

	\seealso{16.3, 16.4}
\end{faq}
