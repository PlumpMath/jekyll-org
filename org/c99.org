# -*-org-*-
#+STARTUP: odd
#+OPTIONS: toc:4
#+BEGIN_HTML
---
layout: org
id: c99
title: c99
lead: Collection of C99 features
---
#+END_HTML

* Authentic Contents from 

  - [[http://infocenter.arm.com/help/topic/com.arm.doc.dui0205j/CACEBJGG.html][RealView Compilation Tools Compiler User Guide Version 4.0]]
  - [[http://david.tribble.com/text/cdiffs.htm][Incompatibilities Between ISO C and ISO C++]]

* language features
*** comments
    like C++, =//= can be used as a one-line comment.

    [C99: §6.8.5] 
    [C++98: §3.3.2, 6.4, 6.5]

*** compound literals

    C99 allows literals having types other than primitive types (e.g.,
    user-defined structure or array types) to be specified in constant
    expressions; these are called /compound literals/. For example:

#+BEGIN_SRC c
struct info
{
    char    name[8+1];
    int     type;
};

extern void  add(struct info s);
extern void  move(float coord[2]);

void predef(void)
{
    add((struct info){ "e", 0 });      // A struct literal
    move((float[2]){ +0.5, -2.7 });    // An array literal
} 
#+END_SRC

    C++ does not support this feature.

    C++ does provides a similar capability through the use of
    non-default class constructors, but which is not quite as flexible
    as the C feature:

#+BEGIN_SRC c++
void predef2()
{
    add(info("e", 0));      // Call constructor info::info()
} 
#+END_SRC

    (This C feature might be provided as an extension by some C++
    compilers, but would probably be valid only for POD structure
    types and arrays of POD types.)

    [C99: §6.5.2, 6.5.2.5] 
    [C++98: §5.2.3, 8.5, 12.1, 12.2]

*** designated initializers

#+BEGIN_SRC c
typedef struct
{
    char *name;
    int rank;
} data;
data vars[10] = { [0].name = "foo", [0].rank = 1,
                  [1].name = "bar", [1].rank = 2,
                  [2].name = "baz", 
                  [3].name = "gazonk" };
#+END_SRC

    C99 introduces the feature of /designated initializers/, which
    allows specific members of structures, unions, or arrays to be
    initialized explicitly by name or subscript. For example:

#+BEGIN_SRC c
struct info
{
    char    name[8+1];
    int     sz;
    int     typ;
};

struct info  arr[] =
{
    [0] = { .sz = 20, .name = "abc" },
    [9] = { .sz = -1, .name = "" }
}; 
#+END_SRC

    Unspecified members are default-initialized.

    C++ does not support this feature.

    (This feature might be provided as an extension by some C++
    compilers, but would probably be valid only for POD structure
    types and arrays of POD types. However, C++ already provides a
    similar capability through the use of non-default class
    constructors.)

    [C99: §6.7.8] 
    [C++98: §8.5.1, 12.1]

*** Hexadecimal floating-point literals

    C99 recognizes hexadecimal floating-point literals, having a "=0x="
    prefix and a "=p=" exponent specifier. For example:

#+BEGIN_SRC c
float  pi = 0x3.243F6A88p+03; 
#+END_SRC

    C99 also provides additional format specifiers for the =printf()=
    and =scanf()= family of standard library functions:

#+BEGIN_SRC c
printf("%9.3a", f);
printf("%12.6lA", d);
#+END_SRC

    (These features are likely to be provided as extensions by many
    C++ compilers.)

    [C99: §6.4.4.2, 6.4.8] 
    [C++98: §2.9, 2.13.3]

*** Flexible array members (FAMs)

    In a =struct= with more than one member, the last member of the
    =struct= can have incomplete array type. Such a member is called a
    /flexible array member/ of the =struct=.

    When a =struct= has a flexible array member, the entire =struct=
    itself has incomplete type.

#+BEGIN_SRC c
extern const int n;
typedef struct
{
  int len;
  char p[];
} str;

void foo(void)
{
  size_t str_size = sizeof(str); // equivalent to offsetoff(str, p)
  str *s = malloc(str_size + (sizeof(char) * n));
}
#+END_SRC


    This is also known as the /struct hack/. This specifies a conforming
    way to declare a structure containing a set of fixed-sized members
    followed by a flexible array member that can hold an unspecified
    number of elements. Such a structure is typically allocated by
    calling =malloc()=, passing it the number of bytes beyond the fixed
    portion of the structure to add to the allocation size. For
    example:

#+BEGIN_SRC c
struct Hack
{
    int     count;    // Fixed member(s)
    int     fam[];    // Flexible array member
};

struct Hack * vmake(int sz)
{
    struct Hack *  p;

    p = malloc(sizeof(struct Hack) + sz*sizeof(int));
                        // Allocate a variable-sized structure

    p->count = sz;
    for (int i = 0; i < sz; i++)
        p->fam[i] = i;

    return p;
} 
#+END_SRC

    C++ does not support flexible array members.

    (This feature might be provided as an extension by some C++
    compilers, but would probably be valid only for POD structure
    types.)
    
    [C99: §6.7.2.1] 
    [C++98: §8.3.4]

    
*** __func__ predefined identifier

    C99 provides a predefined identifier, =__func__=, which acts like
    a string literal containing the name of the enclosing
    function. For example:

#+BEGIN_SRC c
int incr(int a)
{
    fprintf(dbgf, "%s(%d)\n", __func__, a);
    return ++a;
} 
#+END_SRC

    (While this feature is likely to be provided as an extension by
    many C++ compilers, it is unclear what its value would be,
    especially for member functions within nested template classes
    declared within nested namespaces.)

    [C99: §6.4.2.2, 7.2.1.1, J.2] 

*** inline functions

    The C99 keyword =inline= hints to the compiler that invocations of a
    function qualified with =inline= are to be expanded inline. For
    example:

#+BEGIN_SRC c
inline int max(int a, int b)
{
  return (a > b) ? a : b;    
}    
#+END_SRC

    The semantics of =inline= in C99 are different to the semantics of
    =inline= in Standard C++.

*** long long data type
    C99 provides =signed long long= and =unsigned long long= integer types
    to its repertoire of primitive types, which are binary integer
    types at least 64 bits wide.

    C99 also has enhanced lexical rules to allow for integer constants
    of these types. For example:

#+BEGIN_SRC c
long long int           i = -9000000000000000000LL;
unsigned long long int  u = 18000000000000000000LLU; 
#+END_SRC

    C99 also provides several new macros in =<limits.h>=, new format
    specifiers for the =printf()= and =scanf()= family of standard library
    functions, and additional standard library functions that support
    these types. For example:

#+BEGIN_SRC c
void pr(long long i)
{
    printf("%lld", i);
} 
#+END_SRC

    C++ does not recognize these integer types.

    (These features are likely to be provided as extensions by many
    C++ compilers, especially those that provide the same runtime
    library for both C and C++ environments.)

    [C99: §5.2.4.2.1, 6.2.5, 6.3.1.1, 6.4.4.1, 6.7.2, 7.12.9, 7.18.4, 7.19.6.1, 7.19.6.2, 7.20.1, 7.20.6, 7.24.2.1, 7.24.2.2, 7.24.4, A.1.5, B.11, B.19, B.23, F.3, H.2] 
    [C++98: §2.13.1, 3.9.1, 21.4, 22.2.2.2.2, 27.8.2, C.2]

*** Macros with a variable number of arguments

#+BEGIN_SRC c
#define debug(format, ...) fprintf (stderr, format, __VA_ARGS__)

void Variadic_Macros_0()
{
  debug("a test string is printed out along with %x %x %x\n", 12, 14, 20);
}
#+END_SRC

    ----

    C99 supports preprocessor function macros that may take a variable
    number of arguments. Such macros are defined with a trailing '=...='
    token in their parameter lists, and may use the =__VA_ARGS__=
    reserved identifier in their replacement text.

    For example:

#+BEGIN_SRC c
#define DEBUGF(f,...) \
    (fprintf(dbgf, "%s(): ", f), fprintf(dbgf, __VA_ARGS__))

#define DEBUGL(...) \
    fprintf(dbgf, __VA_ARGS__)

int incr(int *a)
{
    DEBUGF("incr", "before: a=%d\n", *a);
    (*a)++;
    DEBUGL("after: a=%d\n", *a);
    return (*a);
} 
#+END_SRC

    C++ does not provide this feature.

    (This feature is likely to be provided as an extension by many C++
    compilers.)

    [C99: §6.10.3, 6.10.3.1, 6.10.3.4, 6.10.3.5] 
    [C++98: §16.3, 16.3.1]

*** Mixed declarations and code

    C99 enables you to mix declarations and code within compound
    statements, like in C++. For example:

#+BEGIN_SRC c
void foo(float i)
{
  i = (i > 0) ? -i : i;
  float j = sqrt(i);    // illegal in C90
}
#+END_SRC

    [C99: §6.8.2] 
    [C++98: §6, 6.3, 6.7]

*** New block scopes for selection and iteration statements

    In a =for= loop, the first expression can be a declaration, like in
    C++. The scope of the declaration extends to the body of the loop
    only. For example:

#+BEGIN_SRC c
extern int max;
for (int n = max - 1; n >= 0; n--)
{
    // body of loop
}
#+END_SRC

    Unlike in C++, you cannot introduce new declarations in a
    =for=-test, =if=-test or =switch=-expression.

*** _Pragma preprocessing operator

    C90 does not permit a =#pragma= directive to be produced as the
    result of a macro expansion. The C99 =_Pragma= operator enables you
    to embed a preprocessor macro in a pragma directive. For example:

#+BEGIN_SRC c
# define RWDATA(X) PRAGMA(arm section rwdata=#X)
# define PRAGMA(X) _Pragma(#X)
RWDATA(foo)  // same as #pragma arm section rwdata="foo"
int y = 1;   // y is placed in section "foo"
Restricted pointers
#+END_SRC

    ----

    C99 provides the =_Pragma= keyword, which operates in a similar
    fashion to the =#pragma= preprocessor directive. For example, these
    two constructs are equivalent:

#+BEGIN_SRC c
#pragma FLT_ROUND_INF   // Preprocessor pragma

_Pragma(FLT_ROUND_INF)  // Pragma statement
#+END_SRC

    C++ does not support the =_Pragma= keyword.

    (This feature is likely to be provided as an extension by many C++
    compilers.)

    [C99: §5.1.1.2, 6.10.6, 6.10.9] 
    [C++98: §16.6]
    
*** Restricted pointers

    The C99 keyword =restrict= enables you to ensure that different
    object pointer types and function parameter arrays do not point to
    overlapping regions of memory. This enables the compiler to
    perform optimizations that might otherwise be prevented because of
    possible aliasing.

    In the following example, pointer =a= does not, and cannot, point to
    the same region of memory as pointer =b=:

#+BEGIN_SRC c
void copy_array(int n, int *restrict a, int *restrict b)
{
    while (n-- > 0)
        *a++ = *b++;
}

void test(void)
{
    extern int array[100];
    copy_array(50, array + 50, array);    // valid
    copy_array(50, array + 1, array);     // undefined behavior
}
#+END_SRC

    Pointers qualified with restrict can however point to different
    arrays, or to different regions within an array.

    ----

    C99 supports the restrict keyword, which allows for certain
    optimizations involving pointers. For example:

#+BEGIN_SRC c
void copy(int *restrict d, const int *restrict s, int n)
{
    while (n-- > 0)
        *d++ = *s++;
} 
#+END_SRC

    C++ does not recognize this keyword.

    A simple work-around for code that is meant to be compiled as
    either C or C++ is to use a macro for the =restrict= keyword:

#+BEGIN_SRC c
#ifdef __cplusplus
 #define restrict    /* nothing */
#endif 
#+END_SRC

    (This feature is likely to be provided as an extension by many C++
    compilers. If it is, it is also likely to be allowed as a
    reference modifier as well as a pointer modifier.)

    [C99: §6.2.5, 6.4.1, 6.7.3, 6.7.3.1, 7, A.1.2, J.2] 
    [C++98: §2.11]


* library features

  The C99 standard introduces several new library features of interest
  to programmers, including:

  - Some features similar to extensions to the C90 standard libraries
    offered in UNIX standard libraries, for example, the =snprintf=
    family of functions.
  - Some entirely new library features, for example, the standardized
    floating-point environment offered in =<fenv.h>=.

  A selection of new library features of C99 that might be of
  particular interest are described in the following sections.
  
*** Additional math library functions in =<math.h>=

    C99 supports additional macros, types, and functions in the
    standard header =<math.h>= that are not found in the corresponding
    C90 standard header.

    New macros found in C99 that are not found in C90 include:

#+BEGIN_SRC c
INFINITY // positive infinity
NAN      // IEEE not-a-number
#+END_SRC

    New generic function macros found in C99 that are not found in C90
    include:

#+BEGIN_SRC c
#define isinf(x) // non-zero only if x is positive or negative infinity
#define isnan(x) // non-zero only if x is NaN
#define isless(x, y) // 1 only if x < y and x and y are not NaN, and 0 otherwise
#define isunordered(x, y) // 1 only if either x or y is NaN, and 0 otherwise
#+END_SRC

    New mathematical functions found in C99 that are not found in C90
    include:

#+BEGIN_SRC c
double acosh(double x); // hyperbolic arccosine of x
double asinh(double x); // hyperbolic arcsine of x
double atanh(double x); // hyperbolic arctangent of x
double erf(double x); // returns the error function of x
double round(double x); // returns x rounded to the nearest integer
double tgamma(double x); // returns the gamma function of x
#+END_SRC

    C99 supports the new mathematical functions for all real
    floating-point types.

    Single precision versions of all existing <math.h> functions are
    also supported.

*** Complex numbers

    In C99 mode, the compiler supports complex and imaginary
    numbers. In GNU mode, the compiler supports complex numbers only.

    For example:

#+BEGIN_SRC c
#include <stdio.h>
#include <complex.h>

int main(void)
{
    complex float z = 64.0 + 64.0*I;
    printf(“z = %f + %fI\n”, creal(z), cimag(z));
    return 0;
}
#+END_SRC

    The complex types are:
    - =float complex=
    - =double complex=
    - =long double complex=.


    Internally,

    C99 provides built-in complex and imaginary floating point types,
    which are declared using the =_Complex= and =_Imaginary= keywords.

    There are exactly three complex types and three imaginary types in C99:

#+BEGIN_SRC c
_Complex float
_Complex double
_Complex long double

_Imaginary long double
_Imaginary double
_Imaginary long double
#+END_SRC

    C99 also provides a standard =<complex.h>= header that contains
    definitions of complex floating point types, macros, and
    constants. In particular, this header defines the following
    macros:

    | =complex=   | Same as =_Complex=          |
    | =imaginary= | Same as =_Imaginary=        |
    | I           | /i  (the complex identity)/ |

    C code that does not include this header is free to use these
    words as identifiers and macro names. This was an intentional part
    of the design of the =_Complex= and =_Imaginary= keywords, since
    this allows existing code that employs the new words to continue
    working as it did before under C89.

    Implicit widening conversions between the complex and imaginary
    types are provided, which parallel the implicit widening
    conversions between the non-complex floating point types.

#+BEGIN_SRC c
// C99 code

#include <complex.h>

complex double square_d(complex double a)
{
    return (a * a);
}

complex float square_f(complex float a)
{
    complex double  d = a;      // Implicit conversion

    return square_d(a);         // Implicit conversion
} 
#+END_SRC

    C++ provides a template class named =complex=, declared in the
    =<complex>= standard header file. This type is incompatible with the
    C99 complex types.

    C++ supports more complex types than C99, in theory, since complex
    is a template class.

#+BEGIN_SRC c++
// C++ code

#include <complex>

complex<float> square(complex<float> a)
{
    return (a * a);
}

complex<int> square(complex<int> a)
{
    return (a * a);
} 
#+END_SRC

    It is possible to define typedefs that will work in both C99 and
    C++, albeit with some limitations:

#+BEGIN_SRC c++
#ifdef __cplusplus

 #include <complex>

 typedef complex<float>           complex_float;
 typedef complex<double>          complex_double;
 typedef complex<long double>     complex_long_double;

#else

 #include <complex.h>

 typedef complex float            complex_float;
 typedef complex double           complex_double;
 typedef complex long double      complex_long_double;

 typedef imaginary float          imaginary_float;
 typedef imaginary double         imaginary_double;
 typedef imaginary long double    imaginary_long_double;

#endif 
#+END_SRC

    Including these definitions allows for portable code that will
    compile as both C and C++ code, such as:

#+BEGIN_SRC c
complex_double square_cd(complex_double a)
{
    return (a * a);
} 
#+END_SRC

    [C99: §6.2.5, 6.3.1.6, 6.3.1.7, 6.3.1.8] 
    [C++98: §26.2]
      

*** Boolean type and =<stdbool.h>=

    C99 introduces the native type =_Bool=. The associated standard
    header =<stdbool.h>= introduces the macros =bool=, =true= and =false= for
    Boolean tests. For example:

#+BEGIN_SRC c
#include <stdbool.h>
bool foo(FILE *str)
{
    bool err = false;
    ...
    if (!fflush(str))
    {
        err = true;
    }
    ...
    return err;
}
#+END_SRC

    The C99 semantics for bool are intended to match those of C++.

    C++ provides =bool=, =false=, and =true= as reserved keywords and
    implements =bool= as a true built-in boolean type.

    C programs that do not include the =<stdbool.h>= header are free to
    use these keywords as identifiers and macro names, which may cause
    compatibility problems when such code is compiled as C++. For
    example:

#+BEGIN_SRC c
typedef short   bool;       // Different

#define false   ('\0')      // Different
#define true    (!false)    // Different

bool  flag =    false; 
#+END_SRC

    The recommended practice is therefore to use these identifiers in
    C only for these special meanings, and only after including
    =<stdbool.h>=.

    (It is likely that an empty =<stdbool.h>= header will be provided by
    most C++ implementations as an extension.)

    [C99: §6.2.5, 6.3.1.1, 6.3.1.2, 7.16, 7.26.7] 
    [C++98: §2.11, 2.13.5, 3.9.1]

*** Extended integer types and functions in =<inttypes.h>= and =<stdint.h>=

    In C90, the =long= data type can serve both as the largest
    integral type, and as a 32-bit container. C99 removes this
    ambiguity through the new standard library header files
    =<inttypes.h>= and =<stdint.h>=.

    The header file =<stdint.h>= introduces the new types:

    - =intmax_t= and =uintmax_t=, that are maximum width signed and
      unsigned integer types
    - =intptr_t= and =unintptr_t=, that are integer types capable of
      holding signed and unsigned object pointers.

    The header file =<inttypes.h>= provides library functions for
    manipulating values of type =intmax_t=, including:

#+BEGIN_SRC c
intmax_t imaxabs(intmax_t x); // absolute value of x
imaxdiv_t imaxdiv(intmax_t x, intmax_t y) // returns the quotient and remainder
                                          // of x / y
#+END_SRC

    ----

#+BEGIN_SRC c
#include <stdint.h>

int  height(int_least32_t x);
int  width(uint16_t x); 
#+END_SRC

    C++ does not provide these types or header files.

    (This feature is likely to be provided as an extension by many C++
    compilers. Some C++ compilers might also provide a =<cstdint>=
    header file as an extension.)

    [C99: §7.1.2, 7.18] 
    [C++98: §17.4.1.2, D.5]

*** Floating-point environment access in =<fenv.h>=

    The C99 standard header file =<fenv.h>= provides access to an IEEE
    754-compliant floating-point environment for numerical
    programming. The library introduces two types and numerous macros
    and functions for managing and controlling floating-point state.

    The new types supported are:

    - =fenv_t=, representing the entire floating-point environment
    - =fexcept_t=, representing the floating-point state.

    New macros supported include:

    - =FE_DIVBYZERO=, =FE_INEXACT=, =FE_INVALID=, =FE_OVERFLOW= and
      =FE_UNDERFLOW= for managing floating-point exceptions
    - =FE_DOWNWARD=, =FE_TONEAREST=, =FE_TOWARDZERO=, =FE_UPWARD= for
      managing rounding in the represented rounding direction
    - =FE_DFL_ENV=, representing the default floating-point
      environment.

    New functions include:

#+BEGIN_SRC c
int feclearexcept(int ex); // clear floating-point exceptions selected by ex
int feraiseexcept(int ex); // raise floating point exceptions selected by ex
int fetestexcept(int ex); // test floating point exceptions selected by x
int fegetround(void); // return the current rounding mode
int fesetround(int mode); // set the current rounding mode given by mode
int fegetenv(fenv_t *penv); return the floating-point environment in penv
int fesetenv(const fenv_t *penv); // set the floating-point environment to penv
#+END_SRC

*** =snprintf= family of functions in =<stdio.h>=

    Using the =sprintf= family of functions found in the C90 standard
    header =<stdio.h>= can be dangerous. In the statement:

#+BEGIN_SRC c
sprintf(buffer, size, "Error %d: Cannot open file '%s'", errno, filename);
#+END_SRC

    the variable size specifies the minimum number of characters to be
    inserted into buffer. Consequently, more characters can be output
    than might fit in the memory allocated to the string.

    The =snprintf= functions found in the C99 version of =<stdio.h>= are
    safe versions of the sprintf functions that prevent buffer
    overrun. In the statement:

#+BEGIN_SRC c
snprintf(buffer, size, "Error %d: Cannot open file '%s'", errno, filename);
#+END_SRC

    the variable size specifies the maximum number of characters that
    can be inserted into buffer. The buffer can never be overrun,
    provided its size is always greater than the size specified by
    size.

*** Type-generic math macros in =<tgmath.h>=

    The new standard header =<tgmath.h>= defines several families of
    mathematical functions that are type generic in the sense that
    they are overloaded on floating-point types. For example, the
    trigonometric function =cos= works as if it has the overloaded
    declaration:

#+BEGIN_SRC c
extern float cos(float x);
extern double cos(double x);
extern long double cos(long double x);
...
#+END_SRC

    A statement such as:

#+BEGIN_SRC c
p = cos(0.78539f); // p = cos(pi / 4)
#+END_SRC

    calls the single-precision version of the =cos= function, as
    determined by the type of the literal =0.78539f=.

    Type-generic families of mathematical functions can be defined in
    C++ using the operator overloading mechanism. The semantics of
    type-generic families of functions defined using operator
    overloading in C++ are different from the semantics of the
    corresponding families of type-generic functions defined in
    =<tgmath.h>=.

    ----

    C99 supports type-generic mathematical functions. These are
    functions that are essentially overloaded on the three
    floating-point types (=float=, =double=, and =long double=) and
    the three complex floating-point types (=complex float=, =complex
    double=, and =complex long double=). To use them, the header file
    =<tgmath.h>= must be included; the functions are defined as
    macros, presumably replaced by implementation-defined names.

    For example, the following is one possible implementation of the
    type-generic functions:

#+BEGIN_SRC c
/* Equivalent <tgmath.h> contents:
 * extern float                sin(float x);
 * extern double               sin(double x);
 * extern long double          sin(long double x);
 * extern float complex        sin(float complex x);
 * extern double complex       sin(double complex x);
 * extern long double complex  sin(long double complex x);
 * etc...
*/

// Macro definitions
#define sin  __tg_sin       // Built-in compiler symbol
#define cos  __tg_cos       // Built-in compiler symbol
#define tan  __tg_tan       // Built-in compiler symbol
etc... 
#+END_SRC

    C++ can also provide type-generic functions, since it is quite
    capable of providing multiple overloaded function definitions.

    (Support for type-generic mathematical functions might be provided
    by many C++ implementations as an extension, although the exact
    nature of such generic/overloaded functions would most likely
    differ substantially from the corresponding C99 implementation. In
    particular, pointers to type-generic functions would probably
    behave differently.)

    [C99: §7.22] 
    [C++98: §13, 13.1, 13.3.1, 13.3.2, 13.3.3]

*** Wide character I/O functions in =<wchar.h>=

    Wide character I/O functions have been introduced in C99. These
    enable you to read and write wide characters from a file in much
    the same way as normal characters.

    ----

    C provides a wide character type, =wchar_t=, that is capable of
    holding a single wide character from an extended character
    set. This type is defined in the standard header files =<stddef.h>=,
    =<stdlib.h>=, and =<wchar.h>=.

    C++ also provides a =wchar_t= type, but it is a reserved keyword
    just like =int=. No header file is required to enable its
    definition.

    This means that C code that does not include any of the standard
    header files listed above is free to use =wchar_t= as an identifier
    or macro name; such code will not compile as C++ code.

#+BEGIN_SRC c
// Does not #include <stddef.h>, <stddef.h>, or <wchar.h>

typedef unsigned short  wchar_t;

wchar_t readwc(void)
{
    ...
} 
#+END_SRC

    The recommended practice is therefore to use the =wchar_t= type only
    for its special meaning, and only after including =<stddef.h>=,
    =<stdlib.h>=, or =<wchar.h>=.

    (It is likely that a =<wchar.h>= header will be provided by most C++
    implementations as an extension. Some C++ compilers might also
    provide an empty =<cwchar>= header as an extension.)

    [C99: §3.7.3, 6.4.4.4, 6.4.5, 7.1.2, 7.17, 7.19.1, 7.20, 7.24] 
    [C++98: §2.11, 2.13.2, 2.13.4, 3.9.1, 4.5, 7.1.5.2]

* Difference between C99 and C++

*** Aggregate Initializer

    C90 requires automatic and register variables of aggregate type
    (=struct=, array, or =union=) to have initializers containing only
    constant expressions. (Many compilers do not adhere to this
    restriction, however.)

    C99 removes that restriction, allowing non-constant expressions to
    be used in such initializers.

    C++ allows non-constant expressions to be used in initializers for
    automatic and register variables. (It also allows arbitrary
    non-constant expressions to be used to initialize static and
    external variables.)

    For example:

#+BEGIN_SRC c
// C and C++ code
void foo(int i)
{
    float   x = (float)i;           // Valid C90, C99, and C++
    int     m[3] = { 1, 2, 3 };     // Valid C90, C99, and C++
    int     g[2] = { 0, i };        // Invalid C90
} 
#+END_SRC

    [C99: §6.7.8] 
    [C++98: §3.7.2, 8.5, 8.5.1]


*** difference in inline functions

    C++ requires all of the definitions for a given inline function to
    be composed of exactly the same token sequence.

    C99, however, allows multiple definitions of a given inline
    function to be different, and does not require the compiler to
    detect such differences or issue a diagnostic.

    Thus the following two example source files, which define two
    slightly different versions of the same inline function,
    constitute acceptable C99 code but invalid C++ code:

#+BEGIN_SRC c
//========================================
// one.c

inline int twice(int i)         // One definition
{
    return i * i;
}

int foo(int j)
{
    return twice(j);
}

//========================================
// two.c

typedef int  integer;

inline integer twice(integer a) // Another definition
{
    return (a * a);
}

int bar(int b)
{
    return twice(b);
}
#+END_SRC

    This should not be a problem in practice, provided that multiple
    inline function definitions occur only in shared header files
    (which ensures that the multiple function definitions are composed
    of the same token sequences).

    [C99: §6.7.4]
    [C++98: §7.1.2]

*** Digraph punctuation tokens

    C++ recognizes two-character punctuation tokens, called
    /digraphs/, which are not recognized by C90. The digraphs and
    their equivalent tokens are:

#+BEGIN_SRC c
<:	[
:>	]
<%	{
%>	}
%:	#
%:%:	##
#+END_SRC

    C99 recognizes the same set of digraphs.

    The following program is valid in both C99 and C++:

#+BEGIN_SRC c
%:include <stdio.h>

%:ifndef BUFSIZE
 %:define BUFSIZE  512
%:endif

void copy(char d<::>, const char s<::>, int len)
<%
    while (len-- >= 0)
    <%
        d<:len:> = s<:len:>;
    %>
%>
#+END_SRC

    [C99: §6.4.6] 
    [C++98: §2.5, 2.12]

*** Implicit function declaration

    C90 allows a function to be /implicitly declared/ at the point of
    its first use (call), assigning it a return type of =int= by
    default. For example:

#+BEGIN_SRC c
/* No previous declaration of bar() is in scope */

void foo(void)
{
    bar();  /* Implicit declaration: extern int bar() */
}
#+END_SRC

    C++ does not allow implicit function declarations. It is invalid
    to call a function that does not have a previous declaration in
    scope.

    C99 no longer allows functions to be implicitly declared. The code
    above is invalid in both C99 and C++.

    [C99: §6.5.2.2] 
    [C++98: §5.2.2]

*** Implicit variable declarations

    C90 allows the declaration of a variable, function argument, or
    structure member to omit the type specifier, implicitly defaulting
    its type to =int=.

    C99 does not allow this omission, and neither does C++.

    The following code is valid in C90, but invalid in C99 and C++:

#+BEGIN_SRC c
static  sizes = 0;         /* Implicit int, error */

struct info
{
    const char *  name;
    const         sz;      /* Implicit int, error */
};

static foo(register i)     /* Implicit ints, error */
{
    auto  j = 3;           /* Implicit int, error */

    return (i + j);
} 
#+END_SRC

    [C99: §6.7, 6.7.2] 
    [C++98: §7, 7.1.5]

*** alternate punctuation token spellings

    C++ provides the following keywords as synonyms for punctuation tokens:

#+BEGIN_SRC c
and	&&
and_eq	&=
bitand	&
bitor	|
compl	~
not	!
not_eq	!=
or	||
or_eq	|=
xor	^
xor_eq	^=
#+END_SRC

    These keywords are also recognized by the C++ preprocessor.

    C90 does not have these built-in keywords, but it does provide a
    standard =<iso646.h>= header file that contains definitions for the
    same words as macros, behaving almost like built-in keywords.

    C++ requires implementations to provide an empty =<iso646.h>=
    header. Including it in a C++ program has no effect on the
    program. However, C code that does not include the =<iso646.h>=
    header is free to use these words as identifiers and macro names,
    which may cause incompatibilities when such code is compiled as
    C++.

#+BEGIN_SRC c
enum oper { nop, and, or, eq, ne };

extern int  instr(enum oper op, struct compl *c); 
#+END_SRC

    The recommended practice for code intended to be compiled as both
    C and C++ is to use these identifiers only for these special
    meanings, and only after including =<iso646.h>=.

#+BEGIN_SRC c
// Proper header inclusion allows for the use of 'and' et al

#ifndef __cplusplus
 #include <iso646.h>
#endif

int foo(float a, float b, float c)
{
    return (a > b  and  b <= c);
} 
#+END_SRC

    [C99: §7.9] 
    [C++98: §2.5, 2.11]

*** Array parameter qualifiers

    C99 provides new declaration syntax for function parameters of
    array types, allowing type qualifiers (the cv-qualifiers =const= and
    =volatile=, and =restrict=) to be included within the first set of
    brackets of an array declarator. The qualifier modifies the type
    of the array parameter itself. For example, the following
    declarations are semantically identical:

#+BEGIN_SRC c
extern void  foo(int str[const]);
extern void  foo(int *const str); 
#+END_SRC

    In both declarations, parameter str is a const pointer to an =int= object.

    C99 also allows the static specifier to be placed within the
    brackets of an array declaration immediately preceding the
    expression specifying the size of the array. The presence of such
    a specifer indicates that the array is composed of at least the
    number of contiguous elements indicated by the size
    expression. (Presumably this is a hint to the compiler for
    optimizing access to elements of the array.) For example:

#+BEGIN_SRC c
void baz(char s[static 10])
{
    // s[0] thru s[9] exist and are contiguous
    ...
} 
#+END_SRC

    None of these new syntactic features are recognized by C++.

    (These features might be provided as an extension by some C++ compilers.)

    [C99: §6.7.5, 6.7.5.2, 6.7.5.3] 
    [C++98: §7.1.1, 7.1.5.1, 8.3.4, 8.3.5, 8.4]

*** Character literals

    In C, character literals such as ='a'= have type =int=, and thus
    =sizeof('a')= is equal to =sizeof(int)=.

    In C++, character literals have type =char=, and thus =sizeof('a')= is
    equal to =sizeof(char)=.

    This difference can lead to inconsistent behavior in some code
    that is compiled as both C and C++.

#+BEGIN_SRC c
memset(&i, 'a', sizeof('a'));   // Questionable code 
#+END_SRC

    In practice, this is probably not much of a problem, since
    character constants are implicitly converted to type int when they
    appear within expressions in both C and C++.

    [C99: §6.4.4.4] 
    [C++98: §2.13.2]

*** =clog= identifier

    C99 declares =clog()= in =<math.h>= as the complex natural
    logarithm function.

    C++ declares =std::clog= in =<iostream>= as the name of the
    standard error logging output stream (analogous to the =stderr=
    stream). This name is placed into the global namespace if the
    =<math.h>= header is included, and refers to the logarithm
    function. If =<math.h>= defines clog as a preprocessor macro name,
    it can cause problems with other C++ code.

#+BEGIN_SRC c++
// C++ code

#include <iostream>
using std::clog;

#include <math.h>               // Possible conflict

void foo(void)
{
    clog << clog(2.718281828) << endl;
                                // Possible conflict
} 
#+END_SRC

    Including both the =<iostream>= and the =<cmath>= headers in C++
    code places both =clog= names into the =std::= namespace, one
    being a variable and the other being a function, which should not
    cause any conflicts.

#+BEGIN_SRC c++
// C++ code

#include <iostream>
#include <cmath>

void foo(void)
{
    std::clog << std::clog(2.718281828) << endl;
                                // No conflict; different types
}

void bar(void)
{
    complex double  (* fp)(complex double);

    fp = &std::clog;            // Unambiguous
} 
#+END_SRC

    It would appear that the safest approach to this potential
    conflict would be to avoid using both forms of =clog= within the
    same source file.

    [C99: §7.3.7.2] 
    [C++98: §27.3.1]

*** comma operator results

    The comma operator in C always results in an r-value even if its
    right operand is an l-value, while in C++ the comma operator will
    result in an l-value if its right operand is an l-value. This
    means that certain expressions are valid in C++ but not in C:

#+BEGIN_SRC c
int     i;
int     j;

(i, j) = 1;     // Valid C++, invalid C 
#+END_SRC

    [C99: §6.5.3.4, 6.5.17] 
    [C++98: §5.3.3, 5.18]

    
*** =const= linkage

    C specifies that a variable declared with a =const= qualifier is not
    a modifiable object. In all other regards, though, it is treated
    the same as any other variable. Specifically, if a =const= object
    with file scope is not explicitly declared =static=, its name has
    /external linkage/ and is visible to other source modules.

#+BEGIN_SRC c
const int           i = 1;  // External linkage

extern const int    j = 2;  // 'extern' optional
static const int    k = 3;  // 'static' required 
#+END_SRC

    C++ specifies that a =const= object with file scope has /internal
    linkage/ by default, meaning that the object's name is not visible
    outside the source file in which it is declared. A =const= object
    must be declared with an explicit =extern= specifier in order to be
    visible to other source modules.

#+BEGIN_SRC c++
const int           i = 1;  // Internal linkage

extern const int    j = 2;  // 'extern' required
static const int    k = 3;  // 'static' optional 
#+END_SRC

    The recommended practice is therefore to define constants with an
    explicit =static= or =extern= specifier.

    [C99: §6.2.2, 6.7.3] 
    [C++98: §7.1.5.1]

*** Duplicated typedefs

    C does not allow a given =typedef= to appear more than once in the
    same scope.

    C++ handles =typedef=⁠s and type names differently than C, and
    allows redundant occurrences of a given =typedef= within the same
    scope.

    Thus the following code is valid in C++ but invalid in C:

#+BEGIN_SRC c
typedef int  MyInt;
typedef int  MyInt;     // Valid C++, invalid C 
#+END_SRC

    This means that =typedef=⁠s that might be included more than once in
    a program (e.g., common typedefs that occur in multiple header
    files) should be guarded by preprocessing directives if such
    source code is meant to be compiled as both C and C++. For
    example:

#+BEGIN_SRC c
//========================================
// one.h

#ifndef MYINT_T
 #define MYINT_T
 typedef int  MyInt;
#endif
...

//========================================
// two.h

#ifndef MYINT_T
 #define MYINT_T
 typedef int  MyInt;
#endif
... 
#+END_SRC

    Thus code can include multiple header files without causing an
    error in C:

#+BEGIN_SRC c
// Include multiple headers that define typedef MyInt
#include "one.h"
#include "two.h"

MyInt   my_counter = 0; 
#+END_SRC

    [C99: §6.7, 6.7.7] 
    [C++98: §7.1.3]

*** Variable-length arrays (VLAs)

    C99 supports variable-length arrays, which are arrays of automatic
    storage whose size is determined dynamically at program execution
    time. For example:

#+BEGIN_SRC c
size_t sum(int sz)
{
    float   arr[sz];      // VLA, dynamically allocated

    while (sz-- > 0)
        arr[sz] = sz;
    return sizeof(arr);   // Evaluated at runtime
} 
#+END_SRC

    C99 also provides new declaration syntax for function parameters
    of VLA types, allowing a variable identifier or a '=*=' to occur
    within the brackets of an array function parameter declaration in
    place of a constant integer size expression. The following example
    illustrates the syntax involved in passing VLAs to a function:

#+BEGIN_SRC c
extern float  sum_square(int n, float a[*]);

float sum_cube(int n, float a[m])
{
    ...
}

void add_seq(int n)
{
    float   x[n];       // VLA
    float   s;

    ...
    s = sum_square(n, x) + sum_cube(n, x);
    ...
} 
#+END_SRC

    VLA function parameter declarations using a '=*=' can only appear in
    function declarations (with prototypes) and not in function
    definitions. Note that this capability also affects the way =sizeof=
    expressions are evaluated.

    C++ does not support VLAs.

    [C99: §6.7.5, 6.7.5.2, 6.7.5.3, 6.7.6] 
    [C++98: §8.3.4, 8.3.5, 8.4]

*** Dynamic =sizeof= evaluation

    Because C99 supports variable-length arrays (VLAs), the =sizeof=
    operator does not necessarily evaluate to a constant
    (compile-time) value. Any expression that involves applying the
    sizeof operator to a VLA operand must be evaluated at runtime (any
    other use of =sizeof= can be evaluated at compile time). For
    example:

#+BEGIN_SRC c
size_t dsize(int sz)
{
    float   arr[sz];          // VLA, dynamically allocated

    if (sz <= 0)
        return sizeof(sz);    // Evaluated at compile time
    else
        return sizeof(arr);   // Evaluated at runtime
} 
#+END_SRC

    C++ does not support VLAs, so C code that applies the =sizeof=
    operator to VLA operands will cause problems when compiled as C++.

    [C99: §6.5.3.4, 6.7.5, 6.7.5.2] 
    [C++98: §5.3, 5.3.3]

*** Empty parameter lists

    C distinguishes between a function declared with an empty
    parameter list and a function declared with a parameter list
    consisting of only =void=. The former is an unprototyped function
    taking an unspecified number of arguments, while the latter is a
    prototyped function taking no arguments.

#+BEGIN_SRC c
// C code

extern int  foo();          // Unspecified parameters
extern int  bar(void);      // No parameters

void baz()
{
    foo(0);         // Valid C, invalid C++
    foo(1, 2);      // Valid C, invalid C++

    bar();          // Okay in both C and C++
    bar(1);         // Error in both C and C++
} 
#+END_SRC

    C++, on the other hand, makes no distinction between the two
    declarations and considers them both to mean a function taking no
    arguments.

#+BEGIN_SRC c++
// C++ code

extern int  xyz();

extern int  xyz(void);  // Same as 'xyz()' in C++,
                        // Different and invalid in C 
#+END_SRC

    For code that is intended to be compiled as either C or C++, the
    best solution to this problem is to always declare functions
    taking no parameters with an explicit =void= prototype. For example:

#+BEGIN_SRC c
// Compiles as both C and C++
int bosho(void)
{
    ...
} 
#+END_SRC

    Empty function prototypes are a deprecated feature in C99 (as they
    were in C89).

    [C99: §6.7.5.3] 
    [C++98: §8.3.5, C.1.6.8.3.5]

*** Empty preprocessor function macro arguments

    C99 allows preprocessor function macros to be specified with empty
    (missing) arguments.

#+BEGIN_SRC c
#define ADD3(a,b,c)  (+ a + b + c + 0)

ADD3(1, 2, 3)   => (+ 1 + 2 + 3 + 0)
ADD3(1, 2, )    => (+ 1 + 2 + + 0)
ADD3(1, , 3)    => (+ 1 + + 3 + 0)
ADD3(1,,)       => (+ 1 + + + 0)
ADD3(,,)        => (+ + + + 0) 
#+END_SRC

    C++ does not support empty preprocessor function macros arguments.

    (This feature is likely to be provided as an extension by many C++
    compilers.)

    [C99: §6.10.3, 6.10.3.1] 
    [C++98: §16.3., 16.3.1]

*** Enumeration constants

    Enumeration constants in C are essentially just named constants of
    type =signed int=. As such, they are constrained to having an
    initialization value that falls within the range [ =INT_MIN=,
    =INT_MAX= ]. This also means that for any given enumeration
    constant =RED=, the values of =sizeof(RED)= and =sizeof(int)= are
    always the same.

    C++ enumeration constants have the same type as their enumeration
    type, which means that they have the same size and alignment as
    their underlying integer type. This means that the values of
    =sizeof(RED)= and =sizeof(int)= are not necessarily the same for
    any given enumeration constant =RED=. Enumeration constants also
    have a wider range of possible underlying types in C++ than in C:
    =signed int=, =unsigned int=, =signed long=, and =unsigned
    long=. As such, they also have a wider range of valid
    initialization values.

    This may cause incompatibilities for C code compiled as C++, if
    the C++ compiler chooses to implement an enumeration type as a
    different size than it would be in C, or if the program relies on
    the results of expressions such as =sizeof(RED)=.

#+BEGIN_SRC c
enum ControlBits
{
    CB_LOAD =   0x0001,
    CB_STORE =  0x0002,
    ...
    CB_TRACE =  LONG_MAX+1,       // (Undefined behavior)
    CB_ALL =    ULONG_MAX
}; 
#+END_SRC

    [C99: §6.4.4.3, 6.7.2.2] 
    [C++98: §4.5, 7.2]

*** Enumeration types

    C specifies that each enumerated type is a unique type, distinct
    from all other enumerated types within the same program. The
    implementation is free to use a different underlying primitive
    integer type for each enumerated type. This means that
    =sizeof(enum A)= and =sizeof(enum B)= are not necessarily the
    same. This also means, given that =RED= is an enumeration constant
    of type =enum Color=, that =sizeof(RED)= and =sizeof(enum Color)=
    are not necessarily the same (since all enumeration constants are
    of type =signed int=).

    All enumeration constants, though, convert to values of type
    =signed int= when they appear in expressions. Since enumeration
    constants cannot portably be wider than =int=, it might appear that
    int is the widest enumeration type; however, implementations are
    free to support wider enumeration integer types. Such extended
    types may be different than the types used by a C++ compiler,
    however.

    In C, objects of enumeration types may be assigned integer values
    without the need for a explicit cast. For example:

#+BEGIN_SRC c
// C code

enum Color { RED, BLUE, GREEN };

int         c = RED;    // Cast not needed
enum Color  col = 1;    // Cast not needed 
#+END_SRC

    C++ also specifies that all enumerated types are unique and
    distinct types, but it goes further than C to enforce this. In
    particular, a function name can be overloaded to take an argument
    of different enumerated types. While objects of enumerated types
    implicitly convert to integer values, integer values require an
    explicit cast to be converted into enumerated types. Implicitly
    converted enumeration values are converted to their underlying
    integer type, which is not necessarily =signed int=. For example:

#+BEGIN_SRC c++
// C++ code

enum Color { ... };

enum Color setColor(int h)
{
    enum Color  c;

    c = h;             // Error, no implicit conversion
    return c;
}

int hue(enum Color c)
{
    return (c + 128);  // Implicit conversion,
                       // but might not be signed int
} 
#+END_SRC

    Since a C++ enumeration constant has the same type and size as its
    enumeration type, this means, given that =RED= is an enumeration
    constant of type =enum Color=, that the values of =sizeof(RED)= and
    =sizeof(enum Color)= are exactly the same, which differs from the
    rules in C.

    There is no guarantee that a given enumeration type is implemented
    as the same underlying type in both C and C++, or even in
    different C implementations. This affects the calling interface
    between C and C++ functions. This may also cause incompatibilities
    for C code compiled as C++, if the C++ compiler chooses to
    implement an enumeration type as a different size that it would be
    in C, or if the program relies on the results of expressions such
    as sizeof(RED).

#+BEGIN_SRC c++
// C++ code

enum Color { ... };

extern "C" void  foo(Color c);
                    // Parameter types might not match

void bar(Color c)
{
    foo(c);         // Enum types might be different sizes
} 
#+END_SRC

    [C99: §6.4.4.3, 6.7.2.2] 
    [C++98: §4.5, 7.2]


    
*** Function name mangling

    In order to implement overloaded functions and member functions,
    C++ compilers must have a means of mapping the source names of
    functions into unique symbols in the object code resulting from
    the compile. For example, the functions =::foo(int)=, =::foo(float)=,
    and =Mine::foo()= all have identical names (=foo=) but different
    /calling signatures/. In order for the linker to distinguish between
    the functions during program link time, they must be /mangled/ into
    different symbolic names.

    This differs from the way functions names are mapped into symbolic
    object names in C, which allows for certain cases of type punning
    (between signed and unsigned integer types) and non-prototyped
    extern functions. Therefore C programs compiled as C++ will
    produce different symbolic names, unless the functions are
    explicitly declared as having =extern= "=C=" linkage. For example:

#+BEGIN_SRC c
int  foo(int i);   // Different symbolic names in C and C++

#ifdef __cplusplus
extern "C"
#endif
int  bar(int i);   // Same symbolic name in both C and C++ 
#+END_SRC

    C++ functions are implicitly declared with =extern= "=C++=" linkage.

    Another consequence of C++ function name mangling is that
    identifiers in C++ are not allowed to contain two or more
    consecutive underscores (e.g., the name =foo__bar= is invalid). Such
    names are reserved for the implementation, ostensibly so that it
    may have a guaranteed means of mangling source function names into
    unique object symbolic names. (For example, an implementation
    might choose to mangle the member function =Mine::foo(int)= into
    something like =foo__4Mine_Fi=, which is a symbolic name containing
    consecutive underscores.)

    C does not reserve such names, so a C program is free to use such
    names in any manner. For example:

#+BEGIN_SRC c
void foo__bar(int i)  // Improper C++ name
{ ... } 
#+END_SRC

    [C99: §5.2.4.1, 6.2.2, 6.4.2.1] 
    [C++98: §2.10, 3.5, 17.4.2.2, 17.4.3.1.2, 17.4.3.1.3]

*** Function pointers

    C++ functions have =extern= "=C++=" linkage by default. In order to
    call C functions from C++, the functions must be declared with
    =extern= "=C=" linkage. This is typically accomplished by placing C
    function declarations within an =extern= "=C=" block:

#+BEGIN_SRC c++
extern "C"
{
    extern int  api_read(int f, char *b);
    extern int  api_write(int f, const char *b);
} 
extern "C"
{
    #include "api.h"
} 
#+END_SRC

    But simply declaring functions with =extern= "=C=" linkage is not
    enough to ensure that C++ functions can call C functions
    properly. Specifically, pointers to =extern= "=C=" functions and
    pointers to =extern= "=C++=" functions are not compatible. When
    compiled as C++ code, function pointer declarations are implicitly
    defined as having =extern= "=C++=" linkage, so they cannot be assigned
    addresses of =extern= "=C=" functions. (Function pointers can thus be
    a source of problems when dealing with C API libraries and C
    callback functions.)

#+BEGIN_SRC c++
extern int      mish(int i);    // extern "C++" function

extern "C" int  mash(int i);

void foo(int a)
{
    int  (*pf)(int i);          // C++ function pointer

    pf = &mish;                 // Okay, C++ function address
    (*pf)(a);

    pf = &mash;                 // Error, C function address
    (*pf)(a);
} 
#+END_SRC

    To make the combination of function pointers and =extern= "=C="
    functions work correctly in C++, function pointers that are
    assigned addresses of C functions must be changed to have =extern=
    "=C=" linkage.

    One solution is to use a =typedef= with the proper linkage:

#+BEGIN_SRC c++
extern "C"
{
    typedef int  (*Pcf)(int);   // C function pointer
}

void bar(int a)
{
    int  (*pf)(int i);          // C++ function pointer

    pf = &mish;                 // Okay, C++ function address
    (*pf)(a);

    Pcf  pc;                    // C function pointer

    pc = &mash;                 // Okay, C function address
    (*pc)(a);
} 
#+END_SRC

    [C99: §6.2.5, 6.3.2.3, 6.5.2.2] 
    [C++98: §5.2.2, 17.4.2.2, 17.4.3.1.3]

    

*** IEC 60559 arithmetic support

    C99 allows an implementation to pre-define the =__STD_IEC_559=
    preprocessor macro, indicating that it conforms to certain
    required behavior of the IEC 60559 (a.k.a. IEEE 599) specification
    regarding floating-point arithmetic and library
    functions. Implementations that do not pre-define this macro are
    not require to provide conforming floating-point behavior.

    C++ does not make any special provisions for implementations that
    explicitly support the IEC 60559 floating-point specification.

    Conformance to IEC 60559 floating-point arithmetic, and the
    pre-definition of the =__STD_IEC_559= macro, is likely to be
    provided as an extension by many C++ compilers.

    C99 also allows an implementation to pre-define the
    =__STD_IEC_559_COMPLEX= preprocessor macro to indicate that it
    conforms to the behavior specified by IEC 60559 for complex
    floating-point arithmetic and library functions. This affects the
    way the =_Complex= and =_Imaginary= types are implemented.

    C++ provides library functions for complex floating-point
    arithmetic by providing the =complex<>= template class, declared in
    the standard =<complex>= header file. This type is incompatible with
    the C99 =complex= types.

    Conformance to the complex arithmetic specification, and the
    pre-definition of the =__STD_IEC_559= macro, might also be provided
    by many C++ compilers, and this would indicate how the =complex<>=
    template class is implemented.

    [C99: §6.10.8, F, G] 
    [C++98: §16.8]


*** Library function prototypes

    The C++ standard library header files amend some of the standard C
    library function declarations so as to be more type-safe when used
    in C++. For example, the standard C library function declaration:

#+BEGIN_SRC c++
// <string.h>
extern char *   strchr(const char *s, int c); 
#+END_SRC

    is replaced with these near-equivalent declarations in the C++ library:

#+BEGIN_SRC c++
// <cstring>
extern const char * strchr(const char *s, int c);
extern char *       strchr(char *s, int c); 
#+END_SRC
    
    These slightly different declarations can cause problems when C
    code is compiled as C++ code, such as:

#+BEGIN_SRC c++
// C code
const char * s = ...;
char *       p;

p = strchr(s, 'a');             // Valid C, invalid C++ 
#+END_SRC

    This kind of code results in an attempt to assign a =const= pointer
    returned from a function to a non-⁠=const= variable. A simple cast
    corrects the code, making it valid as both C++ and C code, as in:

#+BEGIN_SRC c++
    // Corrected for C++
    p = (char *) strchr(s, 'a');    // Valid C and C++ 
#+END_SRC

    [C99: §7.21.5, 7.24.4.5] 
    [C++98: §17.4.1.2, 21.4]

*** Library header files

    C++ provides the standard C89 library as part of its library.

    C99 adds a few header files that are not included as part of the
    standard C++ library, though:

#+BEGIN_SRC c
<complex.h>
<fenv.h>
<inttypes.h>
<stdbool.h>
<stdint.h>
<tgmath.h>
#+END_SRC

    Even though C++ provides the C89 standard C library headers as
    part of its library, it deems their use as deprecated. Instead, it
    encourages programmers to prefer the equivalent set of C++ header
    files which provide the same functionality as the C header files:

    | =<math.h>=   | /replaced by/ | =<cmath>=   |
    | =<stddef.h>= | /replaced by/ | =<cstddef>= |
    | =<stdio.h>=  | /replaced by/ | =<cstdio>=  |
    | =<stdlib.h>= | /replaced by/ | =<cstdlib>= |
    | etc.         |               | etc.        |

    Deprecating the use of the C header files thus makes the following
    valid C++98 program possibly invalid under a future revision of
    standard C++:

#+BEGIN_SRC c++
#include <stdio.h>     // Deprecated in C++

int main(void)
{
    printf("Hello, world\n");
    return 0;
} 
#+END_SRC

    The program can be modified by removing the use of deprecated
    features in order to make it portable to future implementations of
    standard C++:

#+BEGIN_SRC c++
#ifdef __cplusplus
 #include <cstdio>     // C++ only
 using std::printf;
#else
 #include <stdio.h>    // C only
#endif

int main(void)
{
    printf("Hello, world\n");
    return 0;
} 
#+END_SRC

    [C99: §7.1.2] 
    [C++98: §17.4.1.2, D.5]

*** Nested structure tags

    Nested structure types may be declared within other
    structures. The scope of the inner structure tag extends outside
    the scope of the outer structure in C, but does not do so in
    C++. Structure declarations possess their own scope in C++, but do
    not in C. This applies to any =struct=, =union=, and enumerated types
    declared within a structure declaration. For example:

#+BEGIN_SRC c
struct Outer
{
    struct Inner        // Nested structure declaration
    {
        int         a;
        float       f;
    }           in;

    enum E              // Nested enum type declaration
    {
        UKNOWN, OFF, ON
    }           state;
};

struct Inner    si;     // Nested type is visible in C,
                        // Not visible in C++

enum E          et;     // Nested type is visible in C,
                        // Not visible in C++ 
#+END_SRC

    In order to be visible in C++, the inner declarations must be
    explicitly named using its outer class prefix, or they must be
    declared outside the outer structure so that they have file
    scope. The former case, for example:

#+BEGIN_SRC c++
// C++ code

Outer::Inner     si;    // Explicit type name
Outer::E         et;    // Explicit type name 
#+END_SRC

    And the latter case:

#+BEGIN_SRC c++
    // C and C++ code

    struct Inner            // Declaration is no longer nested
    {
        int         a;
        float       f;
    };

    enum E                  // Declaration is no longer nested
    {
        UKNOWN, OFF, ON
    };

    struct Outer
    {
        struct Inner    in;
        enum E          state;
    }; 
#+END_SRC
    [C99: §6.2.1, 6.2.3, 6.7.2.1, 6.7.2.3] 
    [C++98: §9.9, C.1.2.3.3]

*** Non-prototype function declarations

    C supports non-prototype (a.k.a. /K&R-style/) function
    definitions. (Like C90, C99 deems this as deprecated practice.)
    For example:

#+BEGIN_SRC c
int foo(a, b)     // Deprecated syntax
int  a;
int  b;
{
return (a + b);
} 
#+END_SRC

    C++ allows only prototyped function definitions. So in order to
    compile the example above as C++ code, it must be rewritten in
    function prototype form:

#+BEGIN_SRC c++
int foo(int a, int b)
{
    return (a + b);
} 
#+END_SRC

    [C99: §6.2.7, 6.5.2.2, 6.7.5.3, 6.9.1, 6.11.6, 6.11.7] 
    [C++98: §5.2.2, 8.3.5, 8.4, C.1.6]

*** Old-style casts

    C++ provides four typecast operators:

#+BEGIN_SRC c++
const_cast
dynamic_cast
reinterpret_cast
static_cast
#+END_SRC

    While the following C code is also valid C++98 code, it may not be
    considered valid code in a future revision of the C++ standard:

#+BEGIN_SRC c
char *        p;
const char *  s = (const char *) p; 
#+END_SRC

    One possible work-around is to use macros in C that simulate the
    C++ typecast operators:

#+BEGIN_SRC c
#ifdef __cplusplus
 #define const_cast(t,e)        const_cast<t>(e)
 #define dynamic_cast(t,e)      dynamic_cast<t>(e)
 #define reinterpret_cast(t,e)  reinterpret_cast<t>(e)
 #define static_cast(t,e)       static_cast<t>(e)
#else
 #define const_cast(t,e)        ((t)(e))
 #define dynamic_cast(t,e)      ((t)(e))
 #define reinterpret_cast(t,e)  ((t)(e))
 #define static_cast(t,e)       ((t)(e))
#endif

const char *  s = const_cast(const char *, p); 
#+END_SRC

    All four casts are included above even though =dynamic_cast= is not
    really useful in C code. Perhaps a better definition for
    =dynamic_cast= in C would be:

#+BEGIN_SRC c
#define dynamic_cast(t,e)      _Do_not_use_dynamic_cast
                               // Produces a compile-time error 
#+END_SRC

    C++ also provides functional typecasts, which are not recognized
    in C:

#+BEGIN_SRC c++
f = float(i);   // C++ cast to float; invalid C 
#+END_SRC

    These kinds of typecasts cannot be used in code that is compiled
    as both C and C++.

    [C99: §6.3, 6.54] 
    [C++98: §5.2, 5.2.3, 5.2.7, 5.2.9, 5.2.10, 5.2.11, 5.4, 14.6.2.2, 14.6.2.3]

    

*** One definition rule

    C allows tentative definitions for variables, e.g.:

#+BEGIN_SRC c
int  i;        // Tentative definition
int  i = 1;    // Explicit definition 
#+END_SRC

    C++ does not allow this. Only one definition of any given variable
    is allowed within a program.

    C also allows, or at least does not require a diagnostic for,
    different source files containing conflicting definitions. For
    example:

#+BEGIN_SRC c
//========================================
// one.c

struct Capri                // A declaration
{
    int     a;
    int     b;
};

//========================================
// two.c

struct Capri                // Conflicting declaration
{
    float   x;
}; 
#+END_SRC

    C++ deems this invalid, requiring both definitions to consist of
    the same sequence of tokens.

    C allows definitions of the same function or object in different
    source files to be composed of different token sequences, provided
    that they are semantically identical.

    The C++ rules are more strict, requiring the multiple definitions
    to be composed of identical token sequences. Thus the following
    code, which contains multiple definitions that are semantically
    equivalent but syntactically (token-wise) different, is valid in C
    but invalid in C++:

#+BEGIN_SRC c
//========================================
// file1.c

struct Waffle               // A declaration
{
    int     a;
};

int syrup(int amt)          // A definition
{
    return amt*2;
}

//========================================
// file2.c - Valid C, but invalid C++

typedef int     IType;

struct Waffle               // Equivalent declaration,
{                           // but a different token sequence
    IType   a;
};

IType syrup(IType quant)    // Equivalent definition,
{                           // but a different token sequence
    return (quant*2);
} 
#+END_SRC

    [C99: §6.9.2, J.2] 
    [C++98: §3.2, C.1.2.3.1]

*** Reserved keywords in C99

    C99 has a few reserved keywords that are not recognized by C++:

    | =restrict=   |
    | =_Bool=      |
    | =_Complex=   |
    | =_Imaginary= |
    | =_Pragma=    |


    This will cause problems when C code containing these tokens is
    compiled as C++. For example:

#+BEGIN_SRC c
extern int   set_name(char *restrict n); 
#+END_SRC

    [C99: §6.4.1, 6.7.2, 6.7.3, 6.7.3.1, 6.10.9, 7.3.1, 7.16, A.1.2] 
    [C++98: §2.11]

*** Reserved keywords in C++

    C++ has a few keywords that are not recognized by C99:

    | =bool=         | =mutable=          | =this=     |
    | =catch=        | =namespace=        | =throw=    |
    | =class=        | =new=              | =true=     |
    | =const_cast=   | =operator=         | =try=      |
    | =delete=       | =private=          | =typeid=   |
    | =dynamic_cast= | =protected=        | =typename= |
    | =explicit=     | =public=           | =using=    |
    | =export=       | =reinterpret_cast= | =virtual=  |
    | =false=        | =static_cast=      | =wchar_t=  |
    | =friend=       | =template=         |            |

    C++ also specifically reserves the =asm= keyword, which may or may
    not be reserved in C implementations.

    C code is free to use these keywords as identifiers and macro
    names. This will cause problems when C code containing these
    tokens is compiled as C++. For example:

#+BEGIN_SRC c++
extern int   try(int attempt);
extern void  frob(struct template *t, bool delete); 
#+END_SRC

    [C99: §6.4.1] 
    [C++98: §2.11]

*** Returning =void=
    
    C++ allows functions of return type =void= to explicitly return
    expressions of type =void=. C does not allow void functions to
    return any kind of expression.

    For example:

#+BEGIN_SRC c++
void foo(someType expr)
{
    ...
    return (void)expr;      // Valid C++, invalid C
} 
#+END_SRC

    This is allowed in C++ primarily to allow template functions to
    accept any function return type, including =void=, as a template
    parameter. For example:

#+BEGIN_SRC c++
// C++ code
template <typename T>
T bar(someType expr)
{
    ...
    return (T)expr;         // Valid even if T is void
} 
#+END_SRC

    [C99: §6.8.6.4] 
    [C++98: §3.9.1, 6.6.3]

*** =static= linkage

    Both C and C++ allow objects and functions to have /static file
    linkage/, also known as /internal linkage/. C++, however, deems
    this as deprecated practice, preferring the use of /unnamed
    namespaces/ instead. (C++ objects and functions declared within
    unnamed namespaces have /external linkage/ unless they are
    explicitly declared =static=. C++ deems the use of =static= specifiers
    on objects or function declarations within namespace scope as
    deprecated.)

    While it is not a problem for C code compiled under C++98 rules,
    it may become a problem in a future revision of the C++
    language. For example, the following fragment uses the deprecated
    =static= feature:

#+BEGIN_SRC c
// C and C++ code

static int  bufsize = 1024;
static int  counter = 0;

static long square(long x)
{
    return (x * x);
} 
#+END_SRC

    The preferred way of doing this in C++ is:

#+BEGIN_SRC c++
// C++ code

namespace /*unnamed*/
{
    static int  bufsize = 1024;
    static int  counter = 0;

    static long square(long x)
    {
        return (x * x);
    } 
}
#+END_SRC

    (Note that the use of the =static= specifiers is unnecessary.)

    A possible work-around is to use preprocessor macros and wrappers:

#+BEGIN_SRC c
// C and C++ code

#ifdef __cplusplus
 #define STATIC  static
#endif

#ifdef __cplusplus
namespace /*unnamed*/
{
#endif

STATIC int  bufsize = 1024;
STATIC int  counter = 0;

STATIC long square(long x)
{
    return (x * x);
}

#ifdef __cplusplus
}
#endif 
#+END_SRC

    [C99: §6.2.2, 6.2.4, 6.7.1, 6.9, 6.9.1, 6.9.2, 6.11.2] 
    [C++98: §3.3.5, 3.5, 7.3.1, 7.3.1.1, D.2]

*** String initializers

    C allows character arrays to be initialized with string
    constants. It also allows a string constant initializer to contain
    exactly one more character than the array it initializes, i.e.,
    the implicit terminating null character of the string may be
    ignored. For example:

#+BEGIN_SRC c
char  name1[] =  "Harry";   // Array of 6 char

char  name2[6] = "Harry";   // Array of 6 char

char  name3[] =  { 'H', 'a', 'r', 'r', 'y', '\0' };
                            // Same as 'name1' initialization

char  name4[5] = "Harry";   // Array of 5 char, no null char 
#+END_SRC

    C++ also allows character arrays to be initialized with string
    constants, but always includes the terminating null character in
    the initialization. Thus the last initializer (=name4=) in the
    example above is invalid in C++.

    [C99: §6.7.8] 
    [C++98: §8.5, 8.5.2]

*** String literals are =const=

    In C, string literals have type =char[n]=, but are not modifiable
    (i.e., attempting to modify the contents of a string literal is
    undefined behavior).

    In C++, string literals have type =const char[n]= and are also not
    modifiable.

    When a string literal is used in an expression (or passed to a
    function), both C and C++ implicit convert it into a pointer of
    type =char *=. (The C++ conversion is considered to be two
    conversions, the first being an array-to-pointer conversion from
    type const =char[n]= to type =const char *=, and the second being a
    qualification conversion to type =char *=.)

    The following code is valid in both C and C++.

#+BEGIN_SRC c
extern void  frob(char *s);
                    // Argument is not const char *

void foo(void)
{
    frob("abc");    // Valid in both C and C++,
                    // since literal converts to char *
} 
#+END_SRC

    This language feature does not present an incompatibility between
    C99 and C++98. However, the implicit conversion has been
    deprecated in C++ (presumably to be replaced by a single implicit
    conversion to type =const char *=), which means that a future
    revision of C++ may no longer accept the code above as valid code.

    [C99: §6.3.2.1, 6.4.5, 6.5.1, 6.7.8] 
    [C++98: §2.13.4, 4.2, D.4]

*** Structures declared in function prototypes

    C allows =struct=, =union=, and =enum= types to be declared within
    function prototype scope, e.g.:

#+BEGIN_SRC c
extern void  foo(const struct info { int typ; int sz; } *s);

int bar(struct point { int x, y; } pt)
{ ... } 
#+END_SRC

    C also allows structure types to be declared as function return
    types, as in:

#+BEGIN_SRC c
extern struct pt { int x; }  pos(void); 
#+END_SRC

    C++ does not allow either of these, since the scope of the
    structure declared in this fashion does not extend outside the
    function declaration or definition, making it impossible to define
    objects of that structure type which could be passed as arguments
    to the function or to assign function return values into objects
    of that type.

    Both C and C++ allow declarations of incomplete structure types
    within function prototypes and as function return types, though:

#+BEGIN_SRC c
void  frob(struct sym *s);  // Okay, pointer to incomplete type
struct typ *  fraz(void);   // Ditto 
#+END_SRC

    [C99: §6.2.1, 6.7.2.3, 6.7.5.3, I] 
    [C++98: §3.3.1, 3.3.3, 8.3.5, C.1.6.8.3.5]

*** Typedefs versus type tags

    C requires type tags to be preceded by the =struct=, =union=, or
    =enum= keyword.

    C++ treats type tags as implicit =typedef= names.
    
    Thus the following code is valid C but invalid C++:

#+BEGIN_SRC c
// Valid C, invalid C++

typedef int  type;

struct type
{
    type            memb;   // int
    struct type *   next;   // struct pointer
};

void foo(type t, int i)
{
    int          type;
    struct type  s;

    type = i + t + sizeof(type);
    s.memb = type;
} 
#+END_SRC

    This difference in the treatment of typedefs can also lead to code
    that is valid as both C and C++, but which has different semantic
    behavior. For example:

#+BEGIN_SRC c
int  sz = 80;

int size(void)
{
    struct sz
    { ... };

    return sizeof(sz);      // sizeof(int) in C,
                            // sizeof(struct sz) in C++
} 
#+END_SRC

    [C99: §6.2.1, 6.2.3, 6.7, 6.7.2.1, 6.7.2.2, 6.7.2.3] 
    [C++98: §3.1, 3.3.1, 3.3.7, 3.4, 3.4.4, 3.9, 7.1.3, 7.1.5, 7.1.5.2, 9.1]

*** Variable argument function declarators

    C90 syntax allows a trailing ellipsis in the parameter list of a
    function declarator, which specifies that the function can take
    zero or more additional arguments after the last named parameter.

    C++ also allows variable function argument lists, but provides two
    syntactical forms for this feature.

#+BEGIN_SRC c
/* Variable-argument function declarations */
int  foo(int a, int b, ...);      // Valid C++ and C
int  bar(int a, int b ...);       // Valid C++, invalid C 
#+END_SRC

    [C99: §6.7.5] 
    [C++98: §8.3.5]

*** Void pointer assignments

    C allows a pointer to void (=void *=) value to be assigned to an
    object of any other pointer type without requiring a cast. This
    allows such things as assigning the return value of =malloc()= to a
    pointer variable without the need for an explicit cast.

    C++ does not allow assigning a pointer to =void= directly to an
    object of any other pointer type without an explicit cast. This is
    considered a breach of type safety, so an explicit cast is
    required. Thus the following code is valid C but invalid C++:

#+BEGIN_SRC c
extern void *  malloc(size_t n);

struct object * allocate(void)
{
    struct object *  p;

    p = malloc(sizeof(struct object));
                        // Direct assignment without a cast,
                        // valid C, invalid C++
    return p;
} 
#+END_SRC

    (Both languages allow values of any pointer type to be assigned to
    objects of type pointer to void without requiring an explicit
    cast.

#+BEGIN_SRC c++
void *  vp;
Type *  tp;

vp = tp;    // No explicit cast needed,
            // valid C and C++ 
#+END_SRC

    Such usage is considered type safe.)

    (Note that there are situations in C++ where pointers are
    implicitly converted to type pointer to =void=, such as when
    comparing a pointer of type pointer to =void= to another pointer of
    a different type, but such situations are considered type safe
    since no pointer objects are modified in the process.)

    [C99: §6.2.5, 6.3.2.3, 6.5.15, 6.5.16, 6.5.16.1] 
    [C++98: §3.8, 3.9.2, 4.10, 5.4, 5.9, 5.10, 5.16, 5.17, 13.3.3.2]

*** References

***** C89
      *Programming Languages - C* 
      *ANSI/ISO 9899:1989*, 1989, 
      Available at http://www.ansi.org/.

***** C90
      *Programming Languages - C*
      (with ISO amendments) 
      *ISO/IEC 9899:1990*, 1990, ISO/IEC JTC1/SC22/WG14. 
      Available at http://www.ansi.org/.

***** C99
      *Programming Languages - C *
      *ISO/IEC 9899:1999*, 1999, ISO/IEC JTC1/SC22/WG14. 
      Available at http://www.ansi.org/.

***** C++98
      *Programming Languages - C++*
      *ISO/IEC 14882:1998(E)*, 1998-09-01, 1st ed., ISO/IEC JTC1/SC22. 
      Available at http://www.ansi.org/.

***** STR
      *The C++ Programming Language, Appendix B - Compatibility*
      Bjarne Stroustrup. 
      Third ed., 1997, AT&T. 
      Available in PDF format at http://www.research.att.com/~bs/3rd_compat.pdf.
