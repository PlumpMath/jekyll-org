
\chapter{Structures, Unions, and Enumerations}	\label{chap:struct}
% chapter 2: struct

Structure, union, enumeration은 여러분에게 새로운 data type을 정의할 수
있게 해준다는 공통점을 가집니다.  먼저, structure나 union은 여러분이
member나 field를 선언하여 새 data type을 정의할 수 있고, enumeration의 경우
상수(constant)를 선언하여 새 data type을 정의할 수 있습니다.
동시에 여러분은 새로운 data type에 \EM{tag} name을 줄 수 있습니다.
일단 새 type을 정의했다면, 정의와 동시에 또는 나중에 새 type의 
instance(변수)를 선언할 수 있습니다.

복잡하게도, 기본 타입과 마찬가지로 user-defined type에도 \TT{typedef}를
써서 새 이름을 줄 수 있습니다. 이렇게 했을 때, 여러분은 \TT{typedef} 이름이
(만약 tag 이름이 존재할 경우) tag 이름과는 전혀 상관없다는 것을 아셔야 
합니다.

이 장의 질문들은 다음과 같이 정리되어 있습니다:  질문 2.1부터 2.18은
structure에 대하여, 질문 2.19부터 2.20까지는 union에 대하여,
질문 2.25부터 2.26까지는 bitfield에 대해 다룹니다.

\section{Structure Declaration}
% from 2.1

\begin{faq}
\Q{2.1}
	다음 두 선언의 차이점이 무엇인가요?

\begin{verbatim}
  struct x1 { ...  };
  typedef struct { ...  } x2;
\end{verbatim}

\A
	첫번째 선언은 ``구조체 태그(tag)''를 선언한 것입니다; 두번째 선언은
	``typedef''를 선언한 것입니다.  주 차이점은 첫번째 경우의 타입 이름은
	\TT{struct x1}이며, 두번째 경우의 타입 이름은 간단히 \TT{x2}라는
	것입니다.  즉 두번째 것이 조금 더 추상화된 타입이라 할 수 있습니다.
	--- 즉 사용자들이 \TT{struct}이라는 키워드를 쓰지 않게되어 이 타입이
	구조체인지 아닌지 알 필요가 없습니다.
\end{faq}

\begin{faq}
\Q{2.2}
	다음 코드가 왜 동작하지 않을까요?

\begin{verbatim}
  struct x { ...  };
  x thestruct;
\end{verbatim}

\A
	C 언어는 C++이 아닙니다.  즉 구조체 태그(tag) 이름에 대해 자동으로
	typedef 이름이 만들어지지 않습니다.  질문 2.1을 참고하기 바랍니다.
\end{faq}

\begin{faq}
\Q{2.3}
	구조체가 자신에 대한 포인터를 포함할 수 있나요?
\A
	당연히 포함할 수 있습니다.  질문 1.14를 보기 바랍니다.
\end{faq}

\begin{faq}
\Q{2.4} 
	C 언어에서 추상화된 데이터 타입을 구현하는 가장 좋은 방법을
	알려주세요.
\A
	한 가지 방법은 사용자들이 구조체 포인터를 쓰게 하는 것입니다 ---
	typedef 이름을 쓰는 것이 좋습니다.  이 포인터는 어떤 구조체를
	가리키는 것이며, 이 구조체의 세부 사항은 사용자에게 알려줄 필요가
	없습니다.

\T
	표준 입출력 함수들이 \TT{FILE *} 타입의 인자를
	받는 것을 생각하면 쉽습니다.
\end{faq}

\begin{faq}
\Q{2.6} 
	구조체를 다음과 같이 정의하는 코드를 봤습니다:
\begin{verbatim}
  struct name {
    int namelen;
    char namestr[1];
  };
\end{verbatim}
	그리고 그 코드에서는 namestr에 공간을 할당(allocation)하고, 배열
	\TT{namestr}이 여러 요소를 가진 것처럼 쓰는 것을 봤습니다.  이게
	안전한 방법인가요?
\A
	이것은 인기있는 테크닉 중의 하나이지만 Dennis Ritchie씨는
	이 방법을 ``unwarranted chumminess with the C implementation''이라고
	부릅니다.  이 방법은 공식적인 C 표준에 정확히 부합하지는 않지만,
	현존하는 거의 모든 컴파일러에서 동작합니다.  (배열의 경계를
	검사해주는 컴파일러에서는 경고를 출력할 수도 있습니다.)

%	"unwarranted chumminess with the C implementation."  An official
%	interpretation has deemed that it is not strictly conforming
%	with the C Standard, although it does seem to work under all
%	known implementations.   (Compilers which check array bounds
%	carefully might issue warnings.)

	또 한가지 방법으로는 가변적인 요소를 매우 작게 잡든 대신 아주 크게
	잡는 것입니다; 위의 예에 적용하자면:

\begin{verbatim}
  ...
  char namestr[MAXSIZE];
\end{verbatim}

	\noindent 이 때 \TT{MAXSIZE}는 예상되는 저장될 문자열보다 크게
	잡습니다.
	그러나 이 방법도 표준에 정확히 부합하는 방법도 아닙니다.
	게다가 이런 구조체를 쓸 때에는 매우 주의를 기울여야 합니다.
	왜냐하면 이런 경우에는 컴파일러보다 프로그래머가 그 크기에 대해
	더욱 잘 알고 있기 때문에 (특히, 이런 경우 pointer로만 작업을
	할 수 있습니다.) 컴파일러가 알려주는 정보(경고나 에러)가
	의미없게 됩니다.
	

	\cite{c9x}에서는 ``flexible array member''라는 개념을 소개하고 있고, 
	이는 배열이 구조체의 마지막 멤버로써 쓰일 때에는 배열의 크기 지정을
	생략할 수 있도록 해 줍니다.

\R
	\cite{rationale} \S\ 3.5.4.2; 
	\cite{c9x} \S\ 6.5.2.1.
\end{faq}

\section{Structure Operations}
% from 2.7
\begin{faq}
\Q{2.7}
	구조체가 변수에 대입되고 함수 인자로 전달될 수 있다고 들었지만,
	\cite{kr1}에서는 그렇지 않다고 하는군요.
\A
	\cite{kr1}에서 말한 구조체 연산의 제한은 거의 모든 컴파일러에
	적용되지 않습니다.  심지어는 \cite{kr1}이 출판될 당시에도 말입니다.
	몇몇 오래된 C 컴파일러의 경우, 이 제한이 남아있지만 대부분의
	컴파일러들은 구조체 연산을 지원합니다.  그리고 이 연산들은 이제
	ANSI C 표준의 일부가 되었습니다.  따라서 전혀 거리낌없이 쓰셔도
	좋습니다.

	(구조체가 복사, 전달, 리턴되는 경우, 복사 작업은 통채로(monolithically)
	이루어지기 때문에 구조체 안의 포인터 필드가 가리키는 데이터는 복사되지
	않는다는 것에 주의하시기 바랍니다.)

\R
	\cite{kr1} \S\ 6.2 \page{121}; 
	\cite{kr2} \S\ 6.2 \page{129}; 
	\cite{iso} \S\ 6.1.2.5, \S\ 6.2.2.1, \S\ 6.3.16; 
	\cite{hs} \S\ 5.6.2 \page{133}.
\end{faq}

\begin{faq}
\Q{2.8}
	두 개의 구조체를 자동으로 비교하는 방법이 있나요?
\A
	없습니다.  C 언어의 저수준 레벨으로 구조체를 비교하는 좋은 방법은 (즉
	구조체에 \TT{==} 연산자를 써서) 없습니다.  간단히 바이트 단위로 
	비교하는
	것은, 구조제 필드 사이에 있을지도 모르는 ``hole''들을 생각할 때 좋지
	않습니다 --- 이러한 `hole'은 각 필드가 주어진 정렬(alignment) 방법에
	맞도록 위치시키기 위해 팔요합니다.  질문 2.12를 참고하시기 바랍니다.
	또한 필드 단위로 비교하는 것은 구조체안에 많은 필드가 있을 때,
	적절하지 않습니다.

	여러분이 두 개의 구조체를 비교하길 원한다면, 필드 단위로 구조체를
	비교하는 함수를 직접 만들어야 합니다.

\R
	\cite{kr2} \S\ 6.2 \page{129}; 
	\cite{rationale} \S\ 3.3.9; 
	\cite{hs} \S\ 5.6.2 \page{133}.
\end{faq}

\begin{faq}
\Q{2.10}
	구조체 인자를 받아들이는 함수에 상수(constant)를 전달할 수 있나요?
\A
	이 글을 쓸 당시 C 언어에는 이름 없는(anonymous) 구조체를
	만들 방법이 없었습니다.  따라서 임시 구조체 변수를 만들거나 구조체를
	리턴하는 함수를 써야 합니다.

	\cite{c9x} 표준은 ``compound literal''이라는 개념을 소개합니다;
	`compound literal'의 한가지 형태는 구조체 상수를 쓸 수 있게 해
	줍니다.  예를 들어, \TT{struct point} 타입의 인자를 받는
	\TT{plotpoint()}에 상수 구조체를 전달하려면 다음과 같이 할 수 있습니다:
\begin{verbatim}
  plotpoint((struct point){1, 2});
\end{verbatim}

	(또다른 \cite{c9x} 표준인) ``designated initializer''라는 개념을 함께 쓰면,
	각각의 멤버 이름을 지정할 수도 있습니다:
\begin{verbatim}
  plotpoint((struct point){.x = 1, .y = 2});
\end{verbatim}

	질문 4.10을 참고하기 바랍니다.

\R
	\cite{c9x} \S\ 6.3.2.5, \S\ 6.5.8.
\end{faq}

\begin{faq}
\Q{2.11}
	구조체를 화일에서 읽거나 쓰는 방법은?
\A
	구조체를 화일에 쓸 경우는 대개 \TT{fwrite()} 함수를 씁니다:

\begin{verbatim}
  fwrite(&somestruct, sizeof somestruct, 1, fp);
\end{verbatim}

\noindent
	그리고, 이렇게 쓴 데이터는 \TT{fread()}를 써서 읽을 수 있습니다.
	그러나 쓰여진 데이터 화일은 이식성이 없습니다.  (질문 2.12와 20.5를
	참고하기 바랍니다).  만약 구조체가 포인터를 포함하고 있었다면, 단지
	포인터 값만 기록되기 때문에, 화일에서 이 데이터를 읽을 경우, 의미없는
	값이 됩니다.  또한 데이터 파일의 이식성을 높이기 위해서는
	\TT{fopen()}을 호출할 때, ``\TT{b}'' 플랙을 써야 합니다;
	질문 12.38을 참고하시기 바랍니다.

	좀 더 이식성이 높은 방법은, 구조체를 필드 단위로 읽고 쓰는 함수를
	만들어 쓰는 것입니다.

\R \cite{hs} \S\ 15.13 \page{381}.
\end{faq}

\section{Structure Padding}
% from 2.12

\begin{faq}
\Q{2.12}
	제 컴파일러는 구조체 안에 `hole'을 만들어 넣어서 공간을
	낭비하고 외부 데이터 화일에 ``binary'' I/O를 불가능하게 합니다.
	이 `padding' 기능을 끄거나 구조체 필드의 alignment를 조정할 수
	있을까요?

\A
	아마도 컴파일러에서 이런 제어를 할 수 있는 방법을 제공할 것입니다.
	(\verb+#pragma+를 써서 할 수 있습니다; 질문 11.20을 참고하기
	바랍니다), 그러나 이런 제어를 위한 표준 방법은 없다는 것을 아셔야
	합니다.

	질문 20.5를 참고하기 바랍니다.

\R 
	\cite{kr2} \S\ 6.4 \page{138}; 
	\cite{hs} \S\ 5.6.4 \page{135}.

\end{faq}
\begin{faq}
\Q{2.13}
	구조체 타입에 \TT{sizeof} 연산자를 썼더니, 제가 예상한 것보다
	훨씬 큰 값을 리턴합니다.  왜 그러죠?
\A
	구조체는 필요한 경우 이러한 `padding' 공간을 포함할 수 있습니다.
	이는 구조체가 배열로 만들어질 때, 정렬(alignment) 속성이 보존되도록
	하기 위한 것입니다.  또 배열로 쓰이지 않을 경우에도 이러한 여분의
	`padding'이 남아 있을 수 있습니다.  이는 \TT{sizeof}가 일관된
	크기를 리턴하게 하기 위한 것입니다.
	\seealso{2.12}

\R
	\cite{hs} \S\ 5.6.7 \Page{139--40}.
\end{faq}

\section{Accessing Members}
% from 2.14

\begin{faq}
\Q{2.14}
	구조체 안에서 각각의 필드에 대한 byte offset을 얻을 수 있나요?
\A
	ANSI C는 \TT{offsetof()} 매크로를 정의합니다.  \verb+<stddef.h>+를 
	보시기 바랍니다.  만약에 이 매크로가 없다면 다음과 같이 만들 수
	있습니다:

\begin{verbatim}
  #define offsetof(type, mem) ((size_t) \
    ((char *)&((type *)0)->mem - (char *)(type *)0))
\end{verbatim}

	이 방법은 100\% 이식성이 뛰어난 것이 아닙니다.  어떤 컴파일러에서는 
	이 방법을 쓸 수 없을 수 있습니다.

	질문 2.15에서 힌트를 얻기 바랍니다.

\R
	\cite{iso} \S\ 7.1.6; 
	\cite{rationale} \S\ 3.5.4.2; 
	\cite{hs} \S\ 11.1 \Page{292--3}.
\end{faq}

\begin{faq}
\Q{2.15}
	실행 시간(run-time)에 구조체 필드를 이름으로 access할 수 있습니까?
\A 
	각각의 필드 이름과 offset을 \TT{offsetof()} 매크로를 써서 테이블에
	저장해 두면 됩니다.  \TT{struct a}에서 필드 `\TT{b}'의 오프셋은 다음과
	같이 얻을 수 있습니다:

\begin{verbatim}
  offsetb = offsetof(struct a, b)
\end{verbatim}

	만약 이 구조체 변수를 가리키는 포인터 \TT{structp}가 있고,
	필드 `\TT{b}'가 \TT{int}일때, 위에서 계산한 \TT{offsetb}를
	쓰면 \TT{b}의 값을 다음과 같이 설정할 수 있습니다:

\begin{verbatim}
  *(int *)((char *)structp + offsetb) = value;
\end{verbatim}
\end{faq}

\section{Miscellaneous Structure Questions}
% from 2.17

\begin{faq}
\Q{2.18}
	이 프로그램은 정상적으로 동작하지만 프로그램이 끝났을 때,
	\TT{core}를 만들어 냅니다.  왜 그런가요?

\begin{verbatim}
  struct list {
    char *item;
    struct list *next;
  }

    /* Here is the main program.  */

    main(argc, argv)
    { ...  }
\end{verbatim}

\A
	구조체를 정의할 때 세미콜론(`\TT{;}')을 빠뜨렸기 때문에 \TT{main()}이
	구조체를 리턴하는 함수로 정의되어 버렸습니다.  (중간에 들어간
	주석(comment) 때문에 이 버그를 찾아내기가 더욱 힘들 것입니다)
	대개 구조체를 리턴하는 함수들은 포인터(hidden return pointer)를 마치
	인자가 전달되는 것처럼
	구현되기 때문에, \TT{main()}이 세개의 인자를 받는 것처럼
	만들어집니다.  원래
	C start-up code는 \TT{main()}이 두 개의 인자를 받는 것으로 짜여져
	있으므로, 이 경우 정상적으로 동작할 수 없습니다.  질문 10.9와 16.4를
	참고하기 바랍니다.

\R 
	\cite{ctp} \S\ 2.3 \Page{21--2}.
\end{faq}

\section{Unions}
% from 2.19

\begin{faq}
\Q{2.20}
	\TT{union}을 초기화(initialization)할 수 있습니까?
\A
	현재 C 표준은 \TT{union} 안에, 이름이 있는 첫번째 멤버의 초기화만
	인정합니다.  \cite{c9x}는 ``designated initializer''를 소개하고 있으며, 어떠한
	멤버의 초기값도 쓸 수 있도록 하고 있습니다.

\R
	\cite{kr2} \S\ 6.8 \Page{148--9}; 
	\cite{iso} \S\ 6.5.7; 
	\cite{c9x} \S\ 6.5.8; 
	\cite{hs} \S\ 4.6.7 \page{100}.
\end{faq}

\section{Enumerations}
% from 2.22

\begin{faq}
\Q{2.22}
	열거형(enumeration)을 쓰는 것과 \verb+#define+으로 정의한
	매크로를 쓰는 것과 차이가 있습니까?
\A
	현재 이 둘에는 약간의 차이가 있습니다.  C 표준은 `열거형이
	에러없이 정수형 타입으로 쓰일 수 있다'고 정의할 수 있습니다.
	(달리 표현하면, 이렇게 명백하게 캐스트를 하지 않고 섞어쓸 수 없었다면
	현명하게 열거형을 썼을 때에만 프로그래밍 에러를 잡아 줄 수
	있었을 겁니다.) % TODO: 이게 몬 소리여? -_-;;;;

	(If, on the other hand, such
	intermixing were disallowed without explicit casts, judicious
	use of enumerations could catch certain programming errors.)

	열거형을 썼을 때에 좋은 점은, 수치 값이 자동적으로 대입되기 때문에,
	디버거(debugger)가 열거형 변수를 검사할 때 심볼(symbol) 값으로
	보여줄 수 있다는 점입니다.
	(열거형과 정수형을 섞어쓰는 것이 오류는 아니지만, 좋은 스타일이 아니기
	때문에 어떤 컴파일러는 가벼운 경고를 출력하기도 합니다.)
	열거형을 쓸 때의 단점은 이러한 사소한 경고를 프로그래머가 처리해 줘야
	한다는 것입니다; 어떤 프로그래머들은 열거형 변수의 크기를 제어할 수
	없다는 것에 불평하기도 합니다.

\R
	\cite{kr2} \S\ 2.3 \page{39}, \S\ A4.2 \page{196}; 
	\cite{iso} \S\ 6.1.2.5, \S\ 6.5.2, \S\ 6.5.2.2, Annex F; 
	\cite{hs} \S\ 5.5 \Page{127--9}, \S\ 5.11.2 \page{153}.
\end{faq}

\begin{faq}
\Q{2.24}
	열거형 값을 심볼로 출력할 수 있는 간단한 방법이 있을까요?
\A
	없습니다.  열거형 값을 문자열로 매핑(mapping)시켜주는 
	함수를 직접 만들어야 합니다.  (디버깅 목적으로, 성능 좋은 디버거들은
	자동으로 열거형 값을 심볼로 보여주기도 합니다.)
\end{faq}

\section{Bitfields}
% from 2.25
