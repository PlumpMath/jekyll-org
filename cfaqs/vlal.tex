% $Id$
\chapter{Variable-Length Argument Lists}	\label{chap:vlal}
% chapter 15: vlal
널리 알려지지는 않았지만, C 언어는 함수가 가변 인자를 (즉 인자의 갯수가 
정해지지 않은) 받을 수 있는 기능을 제공합니다.
Variable-length argument list(가변 인자 리스트)는, 드물기는 하지만,
\TT{printf}와 같은 함수들에게는 꼭 필요한 것입니다.
(variable-length argument list는 ANSI C 표준에서 공식적으로 지원하지만,
ANSI C 표준 이전에는 엄격히 말해서 정의되어 있지 않습니다.)

Variable-length argument list를 처리하는 방법은 상당히 기묘하기까지 합니다.
정식으로 varaible-length argument list는 fixed part(고정된 부분)와 
variable-length part(가변 길이)의
두 부분으로 나누어져 있습니다.  우리는 ``variable-length argument list의
variable-length part''라는 과장된 용어를 쓰고 있다는 사실을 발견했지만,
어쩔 수 없습니다 (혹시 여러분이 ``variadic''jdhf ``varargs''라는 용어가
쓰이는 것을 보신 적이 있을지도 모르겠습니다: 두 가지 용어 모두
``having a variable number of arguments.\footnote{정해지지 않은 갯수의 인자를
가지는}''을 뜻합니다.  따라서 ``vararg function'' 또는 ``varargs argument''라고
말할 수도 있습니다.)

Variable-length argument list를 쓰는 것은 세 가지 단계를 거칩니다.
첫째, \TT{va\_list}라는 특별한 pointer type을 써서 선언하고, \TT{va\_start}를
불러서 초기화합니다.
% TODO: errta 참고할 것.. variable argument list로 고쳐야 할 것 같은데..
% initialized to point to (the beginning of the argument list) by calling 
% va_start


\begin{faq}
\Q{15.1}
	\TT{printf()}를 부르기 전에 \verb+#include <stdio.h>+를 쓰라고
	하더군요.  꼭 그럴 필요가 있을까요?
\A
	적절한 프로토타입(prototype)을 현재 영역(scope) 안에 포함시키기
	위해서 입니다.

	어떤 컴파일러에서는 가변 인자 리스트를 쓰는 함수에는 일반 방식과는
	다른 호출 순서(calling sequence)를 사용합니다.
	(It might do so if calls using variable-length argument lists were
	less efficient than those using fixed-length.)
	그러므로 함수의 프로토타입이 (즉 ``\verb+...+''를 포함한 선언)
	영역 안에 있어야 컴파일러가 가변 인자 리스트 처리 메커니즘을
	사용할 수 있습니다.

\R
	\cite{iso} \S\ 6.3.2.2, \S\ 7.1.7; 
	\cite{rationale} \S\ 3.3.2.2, \S\ 4.1.6; 
	\cite{hs} \S\ 9.2.4 \Page{268--9}, \S\ 9.6 \Page{275--6}.
\end{faq}

\begin{faq}
\Q{15.2}
	\TT{printf()}에서 \verb+%f+가 \TT{float}과 \TT{double} 인자 모두에
	쓰일 수 있는 이유는 무엇인가요?
\A
	가변 인자 리스트에서 가변 인자 부분에는 ``default argument promotion''
	이 적용됩니다: \TT{char}와 \TT{short int} 타입은 \TT{int}로
	변경되며(promotion), \TT{float} 타입은 \TT{double} 타입으로
	변경됩니다.  (이 것은 함수의 프로토타입이 없거나 구 방식(old style)으로
	선언된 함수에서 일어나는 `promotion'과 같은 것입니다; 질문
	11.3을 참고하기 바랍니다.) 그러므로
	\TT{printf}의 \verb+%f+ 포맷은 항상 \TT{double} 타입만 받아들이는 셈이
	됩니다.	(비슷한 이유에서 \verb+%c+, \verb+%hd+ 포맷은 항상 \TT{int}만을
	받아 들이게 됩니다.) \seealso{12.9, 12.13}
\R
	\cite{iso} \S\ 6.3.2.2; 
	\cite{hs} \S\ 6.3.5 \page{177}, \S\ 9.4 \Page{272--3}.
\end{faq}

\begin{faq}
\Q{15.3}
	\TT{n}이 \TT{long int}일 경우, 다음 코드에서 문제가 발생합니다:
\begin{verbatim}
  printf("%d", n);
\end{verbatim}
	\noindent 그렇지만 ANSI 함수 프로토타입을 제공했으니, 자동으로
	형 변환이 적용될 거라고 생각합니다.  무엇이 잘못되었나요?
\A
	함수가 가변인자를 받는다면, 프로토타입이 있더라도 가변 인자에 대해서는
	어떠한 정보를 알 수 없습니다.  그러므로 가변 인자로 들어간 인자가
	예상하는 타입과 다를 때에는 반드시 캐스팅을 해 주어야 합니다:
	일반적으로 컴파일러는 가변인자에 대해서는 형변환, 또는 이에 대한 경고도
	해 주지 않습니다.

	\seealso{5.2, 11.3, 12.9, 15.2}
\end{faq}

\begin{faq}
\Q{15.4}
	가변 인자를 방는 함수를 어떻게 만들 수 있을까요?
\A
	\verb+<stdarg.h>+ 헤더 파일에 있는 기능을 사용합니다.

	아래의 함수는 주어진 여러 개의 문자열을 붙여서 \TT{malloc()}으로 할당한
	메모리에 저장해서 리턴하는 함수입니다:

\begin{verbatim}
  #include <stdlib.h>     /* for malloc, NULL, size_t */
  #include <stdarg.h>     /* for va_ stuff */
  #include <string.h>     /* for strcat et al.  */

  char *vstrcat(char *first, ...)
  {
    size_t len;
    char *retbuf;
    va_list argp;
    char *p;

    if (first == NULL)
      return NULL;

    len = strlen(first);

    va_start(argp, first);

    while ((p = va_arg(argp, char *)) != NULL)
      len += strlen(p);

    va_end(argp);

    retbuf = malloc(len + 1);   /* +1 for trailing \0 */

    if (retbuf == NULL)
      return NULL;            /* error */

    (void)strcpy(retbuf, first);

    va_start(argp, first);      /* restart; 2nd scan */

    while ((p = va_arg(argp, char *)) != NULL)
      (void)strcat(retbuf, p);

    va_end(argp);

    return retbuf;
  }
\end{verbatim}

\noindent 사용법은 다음과 같습니다:
\begin{verbatim}
  char *str = vstrcat("Hello, ", "world!", (char *)NULL);
\end{verbatim}

	마지막 인자를 캐스팅한 것을 꼭 주의깊게 보시기 바랍니다;
	질문 5.2, 15.3을 참고하기 바랍니다.  (또한 이 함수를 부른 함수는
	이 함수가 리턴한 문자열을 \TT{free}시켜 주어야 할 책임이 있습니다.)

	\seealso{15.7}

\R
	\cite{kr2} \S\ 7.3 \page{155}, \S\ B7 \page{254}; 
	\cite{iso} \S\ 7.8;
	\cite{rationale} \S\ 4.8; 
	\cite{hs} \S\ 11.4 \Page{296--9}; 
	\cite{ctp} \S\ A.3 \Page{139--141}; 
	\cite{pcs} \S\ 11 \Page{184--5}, \S\ 13 \page{242}.
\end{faq}

\begin{faq}
\Q{15.5}
	\TT{printf()}와 같이 포맷 문자열을 받아들여 처리하는 함수를
	만들어 그 처리를 \TT{printf()}에게 맏기고 싶습니다.
\A
	\TT{vprintf()}, \TT{vfprintf()}, \TT{vsprintf()} 함수를 쓰면
	됩니다.  아래의 \TT{error()} 함수는 에러 메시지를 받아들여
	그 메시지 앞에 ``error: ''를 덧붙이고 newline을 붙여서 출력해주는
	함수입니다:
\begin{verbatim}
  #include <stdio.h>
  #include <stdarg.h>

  void error(char *fmt, ...)
  {
    va_list argp;
    fprintf(stderr, "error: ");
    va_start(argp, fmt);
    vfprintf(stderr, fmt, argp);
    va_end(argp);
    fprintf(stderr, "\n");
  }
\end{verbatim}
	\noindent \seealso{15.7}

\R
	\cite{kr2} \S\ 8.3 \page{174}, \S\ B1.2 \page{245}; 
	\cite{iso} \S\ 7.9.6.7, 7.9.6.8, 7.9.6.9; 
	\cite{hs} \S\ 15.12 \Page{379--80}; 
	\cite{pcs} \S\ 11 \Page{186--7}.
\end{faq}

\begin{faq}
\Q{15.6}
	\TT{scanf()}와 같은 기능을 하는 함수를 만들고 싶습니다.
\A
	\cite{c9x}는 \TT{vscanf()}와 \TT{vfscanf()}, \TT{vsscanf()}를
	지원할 것입니다.  (물론 당장 하기 위해서는 여러분 스스로가
	그러한 함수를 만들어야 합니다.)
\R
	\cite{c9x} \S\ 7.3.6.12--14.
\end{faq}

\begin{faq}
\Q{15.7}
	ANSI 이전의 컴파일러를 사용하고 있습니다.  \verb+<stdarg.h>+가 없는데
	어떻게 하죠?
\A
	\verb+<stdarg.h>+에 해당하는 오래된 헤더파일인 \verb+<varargs.h>+를
	쓰면 됩니다.

\R
	\cite{hs} \S\ 11.4 \Page{296--9}; 
	\cite{ctp} \S\ A.2 \Page{134--139};
	\cite{pcs} \S\ 11 \Page{184--5}, \S\ 13 \page{250}.
\end{faq}

\begin{faq}
\Q{15.8}
	함수에 몇 개의 인자가 전달되었는지를 정확히 알 수 있는 방법이
	있나요?
\A
	호환성있는 방법은 존재하지 않습니다.  어떤 오래된 시스템에서는
	비표준 함수인 \TT{nargs()}를 제공하기도 합니다.  그러나
	이 함수는 인자의 갯수를 리턴하는 게 아니라 전달된 워드 갯수를
	리턴한다는 것입니다.  (구조체나 \TT{long int}, 실수는 여러 개의
	워드로 이루어져 있는 경우가 대부분입니다.)

	가변 인자를 받아 처리하는 함수는 그 자체만으로 인자의 갯수를
	파악할 수 있어야 합니다.  \TT{printf} 계열의 함수들은 포맷 문자열에서
	(\TT{\%d}와 같은) 포맷 specifier를 보고 그 갯수를 파악합니다.
	(그렇기 때문에 \TT{printf()}에 전달된 인자의 갯수가 포맷 문자열과
	맞지 않을 경우에 오류를 일으킵니다.)
	일반적으로 가변 인자가 모두 같은 타입을 받을 경우, 마지막 인자를
	(0, -1, 또는 적절한 널 포인터와 같은) 어떤 특정한 값으로
	설정해서 인자의 갯수를 파악합니다 (질문 5.2, 15.4에서
	\TT{execl()}과 \TT{vstrcat()} 함수의 사용법을 참고하시기 바랍니다).
	마지막으로 인자의 갯수를 미리 파악할 수 있다면, 전체 인자의 갯수를
	가변 인자로 전달하는 것도 좋은 방법입니다.  (although it's usually a
	nuisance for the caller to supply).
\R
	\cite{pcs} \S\ 11 \Page{167--8}.
\end{faq}

\begin{faq}
\Q{15.9}
	제 컴파일러는 다음과 같은 함수를 정의하면 에러를 냅니다.
\begin{verbatim}
  int f(...)
  {
  }
\end{verbatim}
\A
	표준 C에서는 \verb+va_start()+를 쓰려면 적어도 하나의 고정된 인자가
	있어야 한다고 말하고 있습니다.  \seealso{15.10}
\R
	\cite{iso} \S\ 6.5.4, \S\ 6.5.4.3, \S\ 7.8.1.1; 
	\cite{hs} \S\ 9.2 \page{263}.
\end{faq}

\begin{faq}
\Q{15.10}
	가변 인자를 처리하는 함수에서 \TT{float} 인자를 처리하지 못합니다.
	다음 코드가 왜 동작하지 않을까요?
\begin{verbatim}
  va_arg(argp, float)
\end{verbatim}

\A
	가변 인자 리스트에서 가변 인자 부분은 항상 ``default argument
	promotion''이 적용됩니다: 즉 \TT{float} 타입의 인자들은 항상
	\TT{double}로 변환되며, \TT{char}나 \TT{short int}의 경우
	항상 \TT{int}로 변환됩니다.  그러므로 \verb+va_arg(argp, float)+은
	잘못된 코드입니다.  대신 \verb+va_arg(argp, double)+을 써야 합니다.
	비슷한 이유로 \TT{char}, \TT{short}, \TT{int}를 받기 위해서는
	\verb+va_arg(argp, int)+를 써야 합니다.

	% TODO: 아래 문장 번역
	(For analogous reasons, the last "fixed" argument, as handed to
	\verb+va_start()+, should not be widenable, either.)  
	\seealso{11.3, 15.2}
\R
	\cite{iso} \S\ 6.3.2.2; 
	\cite{rationale} \S\ 4.8.1.2; 
	\cite{hs} \S\ 11.4 \page{297}.
\end{faq}

\begin{faq}
\Q{15.11}
	함수 포인터를 \verb+va_arg()+로 뽑아 낼 수 없나요?
\A
	\verb+va_arg()+와 같은 매크로는 함수 포인터와 같은 복잡한 타입을
	사용할 때, 곤란을 겪기도 합니다 (be stymied).
	함수 포인터를 다른 이름으로 \TT{typedef}했다면 문제가 해결될 것입니다.
	\seealso{1.12}
\R
	\cite{iso} \S\ 7.8.1.2; 
	\cite{rationale} \S\ 4.8.1.2.
\end{faq}

\begin{faq}
\Q{15.12}
	가변 인자를 받아서 다시 가변 인자를 처리하는 함수에 넘겨 줄 수 있을까요?
\A
	일반적으로는 불가능합니다.  그러나 가변 인자 대신 \verb+va_list+
	포인터를 받아서 처리하는 (\TT{vfprintf()}와 같은; \seealso{15.5})
	함수를 만들면 됩니다.  이 인자가 실제 인자로 전달되거나, 또
	\verb+va_list+를 처리하는
	함수가 없다면, 호환성 있는 방법은 존재하지 않습니다.
	(이 문제는 시스템에 의존적인(machine-specific) 어셈블리 언어로
	해결할 수도 있습니다; \seealso{15.13})
\end{faq}

\begin{faq}
\Q{15.13}
	런타임에 인자 리스트를 만들어서 함수를 부를 수 있는 방법은 없을까요?
\A
	호환성있는 방법도 없으며, 그런 일을 할 수 있다고 보장할 수도 없습니다.

	실제 인자 리스트를 처리하는 대신 범용 (\verb+void *+) 포인터의 배열을
	넘겨주는 방법을 쓸 수 있습니다.  즉 \TT{main()} 함수의 인자처럼
	사용하는 방법입니다.  (물론 배열을 만들고, 배열의 각 요소에
	원하는 정보를 채우는 작업은 직접 해 주어야 합니다.)

	(\seealso{19.36})
\end{faq}
