% $Id$
\chapter{Null Pointers}	\label{chap:nullptr}
% chapter 5: nullptr


\begin{faq}
\Q{5.1}
	악명높은 `널 포인터'란 게 도대체 뭔가요?

\A
	언어 정의에 의하면 각각의 포인터 타입에 대해, 특별한 값이 --- 
	널(null) 포인터 --- 있어서, 다른 포인터 값들과는 구별되며, 어떤
	오브젝트나 함수를 가리키는 포인터와는 항상 구별되는 포인터를 말합니다.
	즉, 주소를 리턴하는 \verb+&+ 연산자는 절대로 널 포인터를 만들어 낼
	수 없으며, 실패하지 않는 한 \TT{malloc()} 함수도 널 포인터를
	리턴하지 않습니다 (\TT{malloc()}은 실패할 경우, 널 포인터를
	리턴합니다.  그리고 이 것이 널 포인터의 쓰임새 --- ``할당되지 않은''
	또는 ``어떠한 것도 가리키지 않는''을 의미하는 특별한 포인터로
	쓰이는 것 --- 중 하나입니다.

	널 포인터와 초기화되지 않은 포인터\footnote{uninitialized pointer}와는
	개념상 완전히 다릅니다.
	널 포인터는 어떠한 오브젝트나 함수도 가리키지 않는 포인터이고,
	초기와되지 않는 포인터는 어떤 값을 가지는 지 모르므로, 아무
	오브젝트나 가리킬 수 있는 포인터입니다.  질문 1.30, 7.1, 7.31을
	참고하기 바랍니다.

	위에서 설명한 것처럼, C 언어는 각각의 포인터 타입에 따라 널 포인터가
	존재합니다.  그리고 널 포인터의 실제 값은 각 타입에 따라
	서로 다를 수 있습니다.  컴파일러가 각 타입에 따른 실제 값으로
	변경해 주기 때문에 프로그래머들은 각 타입에 따라 서로
	다른 널 포인터의 내부적인 값을 알 필요가 전혀 없습니다
	(질문 5.2, 5.5, 5.6을 참고).

\R
	\cite{kr1} \S\ 5.4 \Page{97--8}; 
	\cite{kr2} \S\ 5.4 \page{102}; 
	\cite{iso} \S\ 6.2.2.3; 
	\cite{rationale} \S\ 3.2.2.3; 
	\cite{hs} \S\ 5.3.2 \Page{121--3}.
\end{faq}

\begin{faq}
\Q{5.2}
	프로그램에서 어떻게 널 포인터를 쓰나요?
\A
	언어 정의에 따라, 포인터가 쓰일 곳(context)에 상수 0을 쓰면
	컴파일할 때 자동으로 널 포인터로 변경됩니다.
	즉, 초기화나, 대입, 비교할 때, 한쪽이 포인터 타입의 변수나
	수식일 경우, 다른 쪽의 0은 컴파일러가 자동으로 널 포인터로
	바꾸어 준다는 뜻입니다.  컴파일러는 이 상수 0을 실제 널 포인터
	값으로 바꾸어 줍니다.  따라서 다음과 같은 코드는 문제될 게 전혀
	없습니다 (질문 5.3 참고):

\begin{verbatim}
  char *p = 0;
  if (p != 0)
\end{verbatim}

	그러나, 함수의 인자로 포인터를 전달할 경우, 인자가 항상 포인터가 쓰일
	곳(pointer context)으로 인식되지 않는다는 것을 주의해야 합니다.
	즉, 컴파일러가 0을 널 포인터로 인식하지 못할 가능성이 있다는
	뜻입니다.  이럴 때에는 널 포인터라는 것을 강제적으로 캐스팅을 써서 알려
	주어야 합니다.  예를 들어, UNIX 시스템 콜인 \TT{execl}은 가변 인자
	리스트\footnote{variable length argument list}를 받습니다.
	이 함수는 인자의 끝을 알리기 위해서 널 포인터를 마지막으로
	전달해야 합니다.  즉:

\begin{verbatim}
  execl("/bin/sh", "sh", "-c", "date", (char *)0);
\end{verbatim}

	\noindent 마지막 인자의 \verb+(char *)+ 캐스팅이 생략될 경우,
	컴파일러는 이를 널 포인터로 인식하지 못하고 단순히 정수 0으로
	인식합니다.  (대부분의 UNIX 매뉴얼은 이 부분을 잘못 설명하고
	있으니 주의해야 합니다.)

	함수의 프로토타입(prototype)이 나온 경우, 인자 전달은 대입 연산으로
	인식되기 때문에, 대부분 캐스팅을 할 필요가 없습니다.  왜냐하면
	함수 프로토타입이 컴파일러에게 적절한 타입이 무엇이라는 것을 알려주기
	때문입니다.  따라서 단순히 0만 전달해도, 컴파일러가 알아서 널
	포인터로 바꾸어 줍니다.  그러나 가변 인자 리스트를 쓰는 함수의 인자는
	프로토타입을 알더라도, 각각의
	인자에 대한 타입을 알 수 없으므로 이런 함수의 인자로 쓰인 널 포인터에는
	반드시 캐스팅을 써 주어야 합니다.  (질문 15.3을 참고하시기 바랍니다.)
	함수의 프로토타입이 있던 없던 상관없이, 무조건 함수 인자로 전달되는
	널 포인터에 캐스팅을 하는 것이 혼동되지 않고 안전할 수 있습니다.

\begin{center}
\begin{tabular}{p{4.2cm}|p{5cm}} \hline
	그냥 0을 써도 좋은 경우:	&
	캐스팅이 반드시 필요한 경우: \\ \hline
	초기화(initialization)	& \\
	대입(assignment)	& \\
	비교(comparison)	& \\
	\begin{flushleft}함수 호출, 
		프로토타입 있음 (prototype in scope) \end{flushleft} & 
		{ \begin{flushleft} 함수 호출, 프로토타입 없음  \linebreak
		(no prototype in scope) \end{flushleft} } \\
	\begin{flushleft}고정된 인자\end{flushleft}	& 
		\begin{flushleft}함수 호출에서 가변 인자 \linebreak 
		(variable argument) 사용 \end{flushleft} \\ \hline
\end{tabular}
\end{center}

\R	\cite{kr1} \S\ A7.7 \page{190}, \S\ A7.14 \page{192}; 
	\cite{kr2} \S\ A7.10 \page{207}, \S\ A7.17 \page{209}; 
	\cite{iso} \S\ 6.2.2.3; 
	\cite{hs} \S\ 4.6.3 \page{95}, \S\ 6.2.7 \page{171}.
\end{faq}

\begin{faq}
\Q{5.3}	포인터가 널 포인터인지 비교하기 위해 ``\verb+if (p)+''라고 쓰는
	것이 안전한가요? 만약 널 포인터의 실제 값이 0이 아닐 경우에는
	어떻게 되는 건가요?
\A	C 언어에서 불리언(boolean) 값이 필요할 때, 거짓은 0을 의미하며,
	참(true)은 0이 아닌 값을 의미하게 됩니다.
	따라서 다음과 같이 쓰게 되면:
\begin{verbatim}
  if (expr)
\end{verbatim}
	\noindent 실제로 `\TT{expr}'이 무엇이든지, 컴파일러는 위의 코드를
	다음의 코드와 같은 것으로 봅니다.
\begin{verbatim}
  if ((expr) != 0)
\end{verbatim}
	따라서 `\TT{expr}'을 질문에서 주어진 `\TT{p}'로 바꾸면,
	`\verb+if (p)+'가 `\verb+if (p != 0)+'이 됩니다.
	그리고 이 수식은 비교를 하는 문맥(comparison context)이기 때문에,
	컴파일러는 0이 널 포인터 상수라는 것을 알고, 실제 널 포인터
	값으로 변경해줍니다.  따라서 실제 널 포인터의 값이 0인지 아닌지는
	알 필요가 전혀 없습니다.

	불리언 부정(not) 연산자인 \verb+!+는 다음과 같이 표현할 수 있습니다:

% TODO: make below a table.
\begin{verbatim}
   !expr   is essentially equivalent to         (expr)?0:1
           or to                                ((expr) == 0)
\end{verbatim}
	따라서 질문의 코드는 다음과 같이 해석할 수 있습니다.
\begin{verbatim}
   if(!p)  is equivalent to                     if (p == 0)
\end{verbatim}
	그러므로 단축형(abbreviation)인 \verb+if (p)+는 전혀 문제될 것이
	없습니다.  그러나 어떤 사람들은 이런 식으로 코딩하는 것이 나쁜
	습관이라고 말합니다 (물론 어떤 사람들은 좋은 습관이라고 말합니다.
	질문 17.10을 참고하기 바랍니다).

	질문 9.2를 참고하기 바랍니다.

\R	\cite{kr2} \S\ A7.4.7 \page{204}; 
	\cite{iso} \S\ 6.3.3.3,	\S\ 6.3.9, \S\ 6.3.13, 
		\S\ 6.3.14, \S\ 6.3.15, \S\ 6.6.4.1, \S\ 6.6.5; 
	\cite{hs} \S\ 5.3.2 \page{122}.
\end{faq}

\begin{faq}
\Q{5.4}	
	그럼 NULL은 무엇이고 어떻게 정의되어(\verb+#define+) 있나요?
\A	
	스타일에 관한 문제이지만, 대부분의 프로그래머들은 프로그램에서
	아예 0을 쓰지 않는 경향이 있습니다.  이 목적으로
	전처리기(preprocessor) 매크로인 NULL을 씁니다.
	그리고 이 매크로는 0으로 정의되어 있습니다 (\verb+<stdio.h>+를 포함한
	여러 헤더 파일에 정의되어 있습니다).  어떤 경우 \verb+(void *)+로
	캐스팅되어 있는 경우도 (질문 5.6 참고) 있습니다.
	따라서 정수 0과 널 포인터 상수인 0을 쉽게 구별하기 위해, 널
	포인터가 오는 곳에 NULL을 사용하는 것입니다.

	NULL을 쓰는 것은 단순히 스타일적인 문제입니다; 전처리기가
	NULL을 0으로 바꾸어주므로, 컴파일러가 볼 때에는 모두 0으로
	보게 됩니다.  따라서 함수 인자로 사용할 경우에는 0을 사용할
	때와 마찬가지로 NULL도 캐스팅을 해줘야 할 필요가 있습니다.

	질문 5.2의 표에서 0 대신에 NULL을 그대로 쓸 수 있습니다 (캐스팅하지
	않는 NULL은 캐스팅하지 않는 0과 같기 때문입니다).

	그러나 NULL은 반드시 포인터가 쓰이는 문맥에서만 쓰여야 합니다.
	질문 5.9를 참고하기 바랍니다.

\R	\cite{kr1} \S\ 5.4 \Page{97--8}; 
	\cite{kr2} \S\ 5.4 \page{102}; 
	\cite{iso} \S\ 7.1.6, \S\ 6.2.2.3; 
	\cite{rationale} \S\ 4.1.5; 
	\cite{hs} \S\ 5.3.2 \page{122}, \S\ 11.1 \page{292}.
\end{faq}

\begin{faq}
\Q{5.5}	
	널 포인터 값으로 0이 아닌 비트를 포함하는 값을 사용하는 시스템에서는
	NULL이 어떻게 정의되어 있나요?

\A	NULL은 컴퓨터에 상관없이 항상 0으로 정의되어 있습니다
	(질문 5.4를 참고하기 바랍니다).

	프로그래머가 널 포인터를 쓸 경우, 0을 쓰던지 NULL을 쓰던지에
	상관없이, 실제 컴퓨터의 내부적인 널 포인터 값을 만들어내는 것은
	컴파일러의 역할입니다.  따라서 컴퓨터에서 내부적으로 표현되는 널 포인터
	값이 0이 아닌 다른 값이더라도 NULL은 무조건 0으로 정의되어 있습니다.
	즉 컴파일러는 포인터 문맥에 쓰인 0은 자동으로 널 포인터 값으로
	변경해 줍니다.  질문 5.2, 5.10, 5.17을 참고하기 바랍니다.
\R
	\cite{iso} \S\ 7.1.6; 
	\cite{rationale} \S\ 4.1.5.
\end{faq}

\begin{faq}
\Q{5.6}
	NULL이 다음과 같이 정의되어 있다면:
\begin{verbatim}
  #define NULL        ((char *)0)
\end{verbatim}

	함수 인자로 NULL을 전달할 때, 캐스팅하지 않아도 되지 않을까요?

\A
	일반적으로 그렇지 않습니다.  어떤 컴퓨터들은 각각 다른 데이터
	타입에 대한 포인터의 내부 표현 방법이 다릅니다.
	따라서 문자를 가리키는 포인터가 필요한 곳에 NULL을 그냥 쓰는 것은
	문제가 없으나, 다른 타입을 가리키는 포인터가 필요한 곳에 그냥 쓰는
	것은 문제가 발생할 수 있습니다.  따라서 문제가 없다고 생각되는 
	다음 코드도 불안하다는 것입니다:

\begin{verbatim}
  FILE *fp = NULL;
\end{verbatim}

	그러나 ANSI C는 NULL을 다음과 같이 정의하는 것을 허락하고
	있습니다:

\begin{verbatim}
  #define NULL ((void *)0)
\end{verbatim}

	그러나 NULL을 위와 같이 정의하는 것은 (homonegeous pointer를
	쓰는 컴퓨터에서만 도움을 줄 수 있습니다만) NULL을 잘못쓰는
	문제를 어느 정도 해결해 줄 수 있습니다 (예를 들어 ASCII NUL
	문자가 와야 하는 곳에 NULL을 쓰는 경우; 질문 5.9 참고).

\R
	\cite{rationale} \S\ 4.1.5.
\end{faq}

\begin{faq}
\Q{5.9}	NULL과 0이 널 포인터 상수로서 완전히 같다면 도대체 어떤 것을
	써야하는 거죠?

\A	대부분의 프로그래머들은 포인터 문맥에서는 반드시 NULL을 써야하는
	것으로 믿고 있습니다.  다른 사람들은 NULL이라는 매크로로 0을
	가리는 것이 오히려 더 혼동을 가져온다고 생각하고 무조건 0을
	쓰는 것을 선호하기도 합니다.  그렇지만 이 질문에는 어떠한 것도
	완전한 해답이 되지 못합니다.  (질문 9.2와 17.10을 참고하기 바람)
	C 프로그래머라면 포인터 문맥에서 NULL과 0을 마음대로 쓸 수 있다는
	것을 알아야 합니다.  그리고 단지 0만을 쓰는 것도 완벽하다는 것도
	알아야 합니다.  (0하고는 달리) 포인터가 올 수 있는 곳이면, NULL을
	쓰는 것은 좋습니다.  그러나 프로그래머가 
	(NULL을 0과 다른 것으로 이해하거나 컴파일러에서
	특별하게 취급한다고 생각하는 등) 포인터 0과 정수 0을 구별하는데
	NULL을 썼느냐에 의존하는 것은 좋지 않습니다.

	다른 종류의 0이 필요한 곳에는 만약 그게 제대로 동작한다 할지라도
	NULL을 쓰면 안됩니다.  왜냐하면 그럴 경우, 잘못된 스타일에 관한
	메시지가 발생하기 때문입니다.  (게다가 ANSI는 NULL을
	 \verb+((void *)0)+으로 정의할 수 있도록 하고 있으므로), 포인터가
	쓰일 수 있는 모든 곳에 NULL을 쓸 수 있는 것도 아닙니다.
	특히 ASCII null 문자 (NUL)이 쓰일 곳에 NULL을 쓰면 안됩니다.
	꼭 매크로를 써야 한다면 다음과 같이 따로 정의해서 쓰는 것이
	더 낫습니다:

\begin{verbatim}
  #define NUL '\0'
\end{verbatim}

\R	\cite{kr1} \S\ 5.4 \Page{97--8}; 
	\cite{kr2} \S\ 5.4 \page{102}.
\end{faq}

\begin{faq}
\Q{5.10}
	그렇지만 NULL의 값이 (0이 아닌 다른 값으로) 변경될 때를
	(내부적으로 0이 아닌 다른 값을 쓰는 컴퓨터) 대비해서 0 대신에
	NULL을 쓰는 것이 더 좋지 않을까요?
\A
	아닙니다.  (NULL을 쓰는 것이 바람직할 수 있지만, 이런 이유에서가
	아닙니다.) 일반적으로 심볼릭(symbolic) 상수가 쓰이는 것은, 실제
	값이 변경될 경우를 대비해서 쓰는 경우가 많지만, 0의 자리에
	NULL이 쓰이는 것은 이런 이유에서가 아닙니다.  다시 말하지만
	언어 자체가 (포인터 문맥에서) 0이 널 포인터를 만들어 낸다고
	정의하고 있습니다.  NULL을 쓰는 것은 단순히 스타일에 관한 문제입니다.
	질문 5.5, 9.2를 참고하기 바랍니다.
\end{faq}

\begin{faq}
\Q{5.12}
	다음과 같은 매크로를 써서 널 포인터가 적절한 타입이
	되도록 하고 있습니다:
\begin{verbatim}
  #define Nullptr(type) (type *)0
\end{verbatim}
	이게 좋은 습관일까요?

\A
	이 트릭은 매우 인기있고 매력적이긴 하지만, 크게 도움이 되지 않습니다.
	이 방법은 대입이나 비교에서 쓸 수 없습니다.
	질문 5.2를 참고하기 바랍니다.
	(게다가 추가적으로 타이핑해야 하는 수고가 필요합니다.) 질문
	9.1과 10.2도 보시기 바랍니다.
\end{faq}

\begin{faq}
\Q{5.13}
	약간 헷갈립니다.  NULL은 0인 것이 보장되어 있고,
	널 포인터는 아니라고 한 것 같은데 맞습니까?

\A
	일반적으로 ``null''과 ``NULL''이 혼용되어 쓰이긴 하지만
	다음 사항은 알아두셔야 합니다:

\begin{enumerate}
	\item	널(null) 포인터에 대한 개념은 질문 5.1에 정의되어 있습니다.
	\item	널 포인터가 실제로 갖게 되는 내부적인 값은 각각의 타입에
	따라 다르며 특정 비트가 0이 아닌 값일 수도 있습니다.  실제 널 포인터의
	값은 컴파일러 제작자나 필요한 것이지 C 프로그래머는 널 포인터가
	실제 어떠한 값인지 전혀 알 필요가 없습니다.
	\item	널 포인터 상수는 정수 상수 0입니다 (질문 5.4 참고).
	\item	NULL 매크로는 0으로 정의(\verb+#define+)되어 있습니다.
	(질문 5.4 참고).
	\item	ASCII 널 문자 (NUL)는 모든 비트가 0인 값으로
	널 포인터와는 이름만 같을 뿐, 전혀 상관이 없습니다.
	\item	널 문자열(null string)은 빈 문자열 (\verb+""+)을 나타내는
	다른 말로, C 언어에서 `널 문자열'이라는 용어를 쓰는 것은
	혼동을 가져옵니다.  비어있는 문자열은 널 문자('\verb+\0+'을
	말하는 것이지, 널 포인터와는 상관 없습니다.
\end{enumerate}

	이 글에서는 ``널 포인터(null pointer)''라는 용어를 위의 1번의 목적으로
	사용합니다.  3 번의 목적으로는 0이나 ``널 포인터 상수''라는 표현을
	쓰며, 4 번의 목적으로 ``NULL''을 사용합니다.
\end{faq}

\begin{faq}
\Q{5.14}
	왜 이토록 널 포인터에 대한 논쟁이 많은 것인가요?
	왜 이런 질문이 자주 나오죠?

\A
	C 프로그래머들은 전통적으로 저수준 기계의 구현(machine
	implementation)에 대해 좀 더 많은 것을 알기 원하는 경향이 있습니다.
	문제는 널 포인터가 소스 코드와 기계 자체에 다 쓰이는 개념이지만,
	실제 기계에서는 0이 아닌 다른 값으로 표현될 수 있다는 데에
	있습니다.  전처리기 매크로인 NULL을 쓰는 것이 나중에 변경될 소지가
	있다는 것처럼 보일 수도 있습니다.  또 ``\verb+if (p == 0)+''이라는
	코드는 0을 포인터형으로 변경하는 것이지만 \TT{p}를 정수형으로
	변환하는 것처럼 보일 수도 있습니다.  마지막으로 여러가지로 쓰이는
	(질문 5.13 참고) ``null''이라는 용어를 건성으로 보는 경향이 있습니다.

	C 언어에서 이런 혼동을 없애기 위한 방법으로는 널 포인터 용도로 쓰기
	위한 (Pascal의\TT{nil}과 같은) 키워드(keyword)를 만드는 것을 생각해
	볼 수 있습니다.  그러면 컴파일러는 ``\TT{nil}''을 적절한 널 포인터로
	바꾸어 줄 수 있을 것이며, 널 포인터가 올 수 없는 곳에서는
	경고를 발생해 줄 수 있을 것입니다.  그러나 현재 C 언어에서
	널 포인터를 나타내는 키워드는 ``\TT{nil}''이 아니라 ``0''입니다.
	그리고 널 포인터가 올 수 없는 곳에 0이 쓰이면, 에러가 발생하는
	것이 아니라 정수 0으로 해석된다는 것이 다릅니다.
\end{faq}

\begin{faq}
\Q{5.15}
	매우 헷갈리는 군요.  널 포인터에 관한 이 모든 사항을
	이해할 수가 없군요.

\A
	이럴 때 취할 수 있는 방법은 다음 두가지의 간단한 규칙을 따르는
	것입니다:
\begin{enumerate}
	\item	소스 코드에서 널 포인터 상수가 필요할 경우, 0이나
	NULL을 씁니다.
	\item	0 또는 NULL이 함수 인자로 쓰일 경우에는, 적절한 타입의
	포인터로 캐스팅해서 사용합니다.
\end{enumerate}
	나머지 사항들은 대부분 사람들이 널 포인터가 실제로 갖는 내부적인
	값에 대해 잘못 이해하고 있고 (꼭 이것을 이해할 필요는 없습니다.),
	함수 호출에 대한 복잡성 때문에 발생하는 것입니다.  (이 복잡성을
	고려하고 논의한다면 두번째 규칙은 매우 보수적(conservative)이라는
	것을 알 수 있습니다.  그러나 해를 끼치지는 않습니다)
	질문 5.1, 5.2, 5.4를 이해하고 5.3, 5.9, 5.13, 5.14를 참고하는
	정도만으로도 충분합니다.
\end{faq}

\begin{faq}
\Q{5.16}
	이런 혼동을 없애기 위해, 단순히 널 포인터가 내부적으로
	0으로 나타내어 진다고 말하는 것이 좋지 않을까요?

\A
	다른 이유없이 그렇게 하는 것은 매우 잘못된 생각입니다.
	왜냐하면 어떤 기계에서는 널 포인터를 쓸 경우, 자동적으로
	하드웨어 트랩(trap)이 발생하도록 해 놓았기 때문에 실제로
	널 포인터가 0이 아닌 다른 값으로 쓰일 수 있기 때문입니다.

	게다가 널 포인터에 대해 잘 이해하기 위해, 실제로 내부적으로
	표현되는 널 포인터의 값을 (0인지 아닌지에 대해) 알 필요가
	전혀 없습니다.  단순히 널 포인터가 내부적으로 0으로 표현된다고
	생각한다고 해서, 코드를 작성하기 쉬워지는 것도 아닙니다.
	(잘못된 \TT{calloc()}에 대한 설명을 질문 7.31에서 참고하기 바랍니다.)
	
	그리고 널 포인터가 0이라고 해도 포인터의 크기가 타입에 따라
	달라질 수 있기 때문에 여전히 함수 호출에서 캐스팅을 해야 합니다.
	(만약 질문 5.14에서 말한 것처럼 ``\TT{nil}''이 널 포인터로 쓰일
	수 있다면 널 포인터가 0인지 아닌지에 대한 논쟁 자체가 의미없는
	것이 될 것입니다.)
\end{faq}

\begin{faq}
\Q{5.17}
	실제로, 0이 아닌 비트 패턴을 사용하는 기계나 각각의
	타입에 따라 다른 형태의 포인터를 쓰는 컴퓨터가 있나요?

\A
	Prime 50 시리즈는 적어도 PL/I 언어에서 널 포인터를 나타내기 위해
	세그먼트 07777, 옵셋 0을 사용합니다.  최근의 모델에서는 \TT{TCNP}
	(Test C Null Pointer) 명령을 쓰기 위해  (C 언어에서)
	세그먼트 0, 옵셋 0을 사용합니다.
	또 오래된 워드 주소를 쓰는(word-addressed) Prime 기계는
	바이트 포인터 (\verb+char *+)보다 워드 포인터 (\verb+int *+)가
	크기가 더 작습니다.

	Data General사의 Eclipse MV 시리즈는 기계 수준에서 세 가지의
	포인터 타입을 제공합니다 (워드, 바이트, 비트 포인터).  C 언어에서는
	두 가지 형태를 사용하며 \verb+char *+와 \verb+void *+는 
	바이트 포인터로, 나머지 포인터는 워드 포인터로 구현됩니다.

	어떤 Honeywell-Bell 메인프레임에서는 널 포인터 값으로 06000을
	사용합니다.

	CDC Cyber 180 시리즈는 링(ring), 세그먼트, 옵셋 부분으로 이루어진
	48 비트 포인터를 사용하며, (링 11의) 대부분의 사용자는 널 포인터로
	0xB00000000000를 사용합니다.  오래된 CDC는 1의 보수(one's complement)
	방식을 사용하며, 잘못된 주소를 포함한 모든 데이터의 예외 상황에
	모든 비트가 1인 수치를 사용합니다.

	오래된 HP3000 시리즈는 위에서 언급한 다른 기계들처럼 \verb+char *+,
	\verb+void *+에 대한 포인터와 나머지 포인터들을 바이트 어드레싱과
	워드 어드레싱을 써서 구현하며, 두 어드레싱이 서로 다른 방식을
	사용합니다.  

	Symbolics Lisp 컴퓨터에서는, (tagged architecture), 아예 수치로
	표현되는 포인터를 제공하지 않습니다.  C 널 포인터는 \verb+<NIL, 0>+으로
	구현됩니다.  (기본적으로 \verb+<object, offset>+을 사용함.)

	8086 계열의 프로세서 (PC 호환) 에서는 `메모리 모델'에 따라
	16 비트 데이터 포인터와 32 비트 함수 포인터를 쓸 수 있습니다.
	또는 32 비트 데이터 포인터와 16 비트 함수 포인터를 쓸 수 있습니다.

	어떤 64 비트 Cray 컴퓨터에서는 \verb+int *+를 한 워드의 하위 48
	비트로 표현하며, \verb+char *+는 나머지 상위 16 비트를 옵셋으로 써서
	표현합니다.

\R
	\cite{kr1} \S\ A14.4 \page{211}.
\end{faq}

\begin{faq}
\Q{5.20}
	run-time에 ``null pointer assignment''라는 에러가
	발생합니다.  이게 무엇을 의미하나요? 또 어떻게 해결할 수 있죠?
\A
	이 메세지는 MS-DOS 용 컴파일러가 자주 발생시키는 전형적인 포인터
	에러 메시지입니다.  즉 널 (또는 초기화되지 않은) 포인터를 써서
	잘못된 위치(대개 디폴트 데이터 세그먼트의 옵셋 0)에 어떤 데이터를
	쓰려할 때 발생합니다.

	어떤 디버거들은 데이터 와치포인트(watchpoint)를 주소 0에
	설정할 수 있도록 해 줍니다.  또는 아예 주소 0 근처의 약 20 바이트
	정도를 다른 곳에 복사해두고 주기적으로 비교해서 변경되었는지를
	검사할 수도 있습니다.  질문 16.8을 참고하기 바랍니다.
\end{faq}
