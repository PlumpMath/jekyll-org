% $Id$
\chapter{Extensions}	\label{chap:ext}
% chapter 21: ext
이 절에서는 역자가 추가한 질문들을 정리해 놓았습니다.

\section{miscellaneous code}	\label{sec:misccode}
이 단락에서는 여러분들이 거의 모든 프로그램 개발에 쓸 수 있는 utility
함수들에 대한 설명입니다.

\begin{faq}	\label{faq:error}
\q
	라이브러리 함수들이 성공적으로 수행되었는지 일일이 리턴값을 조사해서
	에러 메시지를 출력하는 것이 번거롭습니다. 간단히 할 수 있는 방법이
	없을까요?

\A
	다음과 같이 error 함수\footnote{이 \TT{error} 함수는 GNU software
	소스 코드에서 얻은 것을 간략화한 것입니다.}를 만들기 바랍니다.
% TODO: error()가 어떤 GNU software에서 온 것인지 출처를 정확히 밝힐 것.

\begin{verbatim}
  #include <stdarg.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>

  /* 아래 변수는 error()가 몇 번 불렸는지 횟수를 
   * 저장합니다. */
  unsigned int error_message_count;

  /* 아래 함수 포인터가 NULL이면 error() 함수는 
   * stdout을 flush시키고 stderr로 프로그램 이름을
   * 출력하고, ": "를 출력합니다. */
    
  /* error() 함수를 쓰는 프로그램은 반드시
   * program_name이라는 변수를 정의하고 프로그램의
   * 이름(실행 파일 이름)을 지정해야 합니다. */

  void
  error(int status, int errnum, const char *msg, ...)
  {
    va_list argptr;
    
    if (error_print_progname)
      (*error_print_progname)();
    else {
      fflush(stdout);
      fprintf(stderr, "%s: ", program_name);
    }
    
    va_start(argptr, msg);
    vfprintf(stderr, msg, argptr);
    va_end(argptr);
    
    ++error_message_count;
     
    if (errnum)
      fprintf(stderr, ": %s", strerror(errnum));
    putc('\n', stderr);
    fflush(stderr);
    if (status)
      exit(status);
  }
\end{verbatim}

	\noindent 일단 위와 같이 error() 함수를 만들었으면 여러분의
	코드에서 다음과 같이 쓸 수 있습니다.

\begin{verbatim}
  #include <stdio.h>
  #include <errno.h>

  const char *program_name = "sample"

  int
  main(void)
  {
    FILE *fp;
    char *filename = "sample.dat";

    fp = fopen(filename, "r");
    if (fp == NULL)
      error(EXIT_FAILURE, errno, 
            "cannot open file %s.", filename);
    /* ... */
  }
\end{verbatim}

	\noindent 위의 코드를 설명하겠습니다.
        \TT{error()}의 첫번째 인자는 0이 아닌 경우, 
	라이브러리 함수 \TT{exit()}로 전달됩니다.  따라서 
	\verb+<stdlib.h>+에 정의된 0이 아닌 값을 가지는 
	\TT{EXIT\_FAILURE} 상수를 써서 \TT{error()}가 메시지를
	출력하고 프로그램을 종료하도록 합니다

	\TT{error()}에 전달된 두번째 인자인, 
        \TT{errno}는 \verb+<errno.h>+에 정의된 전역 변수로서
        몇몇 라이브러리 함수들이 보고한 에러의 종류를 나타내는
	변수입니다.  이 값은 \TT{error()}가 \TT{strerror} 함수를
        써서 에러를 나타내는 문자열로 바꾼 다음 출력합니다.
        시스템과 라이브러리 함수가 보고한 에러가 아니라면
	\TT{error()}의 두번째 인자로 0을 주면 됩니다.

	\TT{error()}의 세번째 인자부터는 \TT{printf()}가 쓰는
	형식 그대로 쓰시면 됩니다.

	물론 위의 예제가 완벽하지는 않습니다.  여러분은 \TT{error()}
	함수를 쓰기 위해, 앞에서 제시한 \TT{error()} 정의와,
	이 함수가 쓰는 전역 변수들을 적당하게 추가해야 합니다.
	
	에러 함수의 선언과 \TT{va\_list}, \TT{va\_start()}, \TT{va\_end()}에
	관한 것은 \ref{chap:vlal} 절을 참고하기 바랍니다.

\R
% TODO: error()가 어떤 GNU software에서 온 것인지 출처를 정확히 밝힐 것.
	\cite{glibc} \TT{misc/error.*}
\end{faq}

\begin{faq}	\label{str2int}
\q
	User input을 string으로 받은 다음, \TT{atoi} 함수를 써서
	수치로 바꾸어 작업 했습니다.  그런데 가끔 이상한 문제가
	발생합니다.  왜 그럴까요?
\A
	\TT{atoi}는 주어진 문자열을 10진수로 해석해서
	\TT{int}로 바꾸어 주지만, 
	에러는 처리해 주지 않습니다.
	다시 말해서 입력 문자열을 10진수로 처리할 수 없을 때에는
	대개 0을 리턴합니다.
% TODO: atoi가 에러를 만난 경우 0을 리턴하는 것이 표준인가 확인!!!!

	따라서 다음과 같은 함수를 만들어 쓰는 것이 좋습니다:
\begin{verbatim}
  #include <errno.h>

  int
  convint(long int *d, const char *s)
  {
    char *p;
    long int i;

    if (*s == '\0')        /* error: nothing in the source string */
      return -1;
    i = strtol(s, &p, 0);
    if (errno == ERANGE)   /* error: underflow or overflow */
      return -1;

    if (*p != '\0')        /* error: there is unexpected character */
      return -1;

    *d = i;
    return 0;
  }
\end{verbatim}

	위 함수는 두 개의 인자를 받습니다. 첫 인자는 변환한 \TT{long int}를
	저장할
	포인터를 받고, 두 번째 인자는 변환할 문자열을 받습니다.
	리턴 값은 성공적으로 변환한 경우에는 0을, 그렇지 않은 경우에는 $-1$을
	리턴합니다 -- 입력에 예상할 수 없는 문자값이 오거나, 입력이 아예
	없거나(문자열이 \verb+'\0'+인 경우), 변환한 값이 \TT{long int}에
	담을 수 없을 만큼 크거나 작은 경우, 에러로 처리합니다.

	실제 사용한 예는 다음과 같습니다:

\begin{verbatim}
  void
  foo(void)
  {
    char instr[80];
    int i;

    /* instr이 user input을 가지고 있다고 가정 */

    if (convint(&i, instr) < 0) {
      /* error: invalid user input */
    }
    /* ... */
  }
\end{verbatim}

	주의할 것은 이 \TT{convint} 함수가 \TT{atoi}와 똑같이 동작하는 게
	아니라는 것입니다 --- 단순히 리턴값과 인자만의 문제가 아닙니다.
	\TT{atoi}와 \TT{convint}의 다른 점은 크게 다음과 같습니다:

\begin{enumerate}
\item 
	\TT{atoi}는 에러를 검사하지 않습니다.
	따라서 입력이 \verb+"12xyz"+인 경우에 12를 리턴합니다.
	\TT{convint}는 입력 문자열이 완전한 경우에만 처리하므로,
	입력이 \verb+"12xyz"+인 경우에는 \TT{int} 변환을 수행하지 않습니다
	--- 즉 에러로 처리합니다.

\item
	\TT{atoi}의 리턴 타입이 \TT{int}인 반면, \TT{convint}의 경우
	\TT{long int}입니다.

\item
	\TT{atoi}는 10진수만 처리할 수 있는 반면, \TT{convint}는
	\TT{strtol}의 세번째 인자로 0을 주었기 때문에, 8진수나 16진수도
	처리할 수 있습니다; 16진수의 경우 문자열 앞에 \verb+"0x"+를 붙여야
	하며, 8진수의 경우에 문자열 앞에 \verb+"0"+을 붙여야 합니다.
% TODO: strtol의 세번째 인자를 0으로 한 것이 표준에 맞는지 확인!!!
\end{enumerate}

\end{faq}

\section{Debugging}	\label{sec:debugging}
이 단락에서는 debugging시 참고할 수 있는 여러가지 hint를 모았습니다.

\begin{faq}	\label{faq:good-debugger}
\q
	좋은 debugger를 추천해 주세요.
\A
	어떤 C 컴파일러가 가장 좋은 것인가?와 마찬가지로 해답이 나오기
	힘든 질문입니다 ;-)

% TODO: GDB 이외의 debugger 소개,
%       non-UNIX system에서 gdb를 쓸 수 있나? --- check

	성능 좋고, 공개용인 GDB(GNU symbolic debugger)를 추천합니다.
	GDB를 바로 command-line에서 사용하는 것은 가장 쉬운 방법이긴
	하지만, \TT{vi}를 쓰지 않고 \TT{ed}를 써서 작업하는 겪이 됩니다.

	GNU Emacs에서는 GDB를 편하게 쓸 수 있는 mode를 제공하며,
	DDD는 GDB를 써서 X window system에서 편하게 쓸 수 있는
	interface를 제공합니다.

% TODO: specify the homepage of the DDD
% TODO: ???

\end{faq}


\begin{faq}	\label{faq:segfault-after-main}
\q
	제가 만든 프로그램은 \TT{main()}을 끝낸 다음에 
	``segmentation fault''를 출력하고 끝나 버립니다. 왜 그럴까요?

\A
	간단히 말해 C 언어로 작성한 프로그램은 \TT{main()}과 함께 시작하여
	\TT{main()}이 끝나면 종료하게 됩니다.  컴파일러가 만들어 낸
	object file을 executable 파일로 변환하는 과정에서,
	command-line 인자인 \TT{argc}와 \TT{argv}를 설정하고,
	\TT{main()}이 종료한 다음 OS에게 control를 넘겨주는 assembler
	루틴이 들어가는 데,  프로그래머의 실수로 assembler routine으로
	돌아가는 리턴 address가 저장되어 있는 stack을 건드리게 되면
	(in technical term, write over the stack where the return
	address is stored.) 그러한 상황이 발생하곤 합니다.

	일단 \TT{main} 함수 내에서 선언된 local 배열이 있나 조사하고,
	있다면, 그 배열의 범위를 벗어난 작업이 있었는지 확인하시기
	바랍니다.
\end{faq}


\begin{faq}
\q
	이 글은 어떤 툴로 만든 것인가요?

\A
	이 글은 \LaTeX와 한글 \LaTeX 패키지인 H\LaTeX을 써서 만든 것입니다.
\end{faq}
